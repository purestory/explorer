// frontend/script.js 의 전체 내용 (수정된 함수 포함)

// 전역 변수
const API_BASE_URL = window.location.hostname === 'itsmyzone.iptime.org' ? 
    window.location.origin : window.location.origin;
let currentPath = '';
let selectedItems = new Set();
let clipboardItems = [];
let clipboardOperation = ''; // 'cut' or 'copy'
let isDragging = false;
let startX, startY;
let listView = true; 
let diskUsage = null;
let sortField = 'name'; 
let sortDirection = 'asc'; 
let fileInfoMap = new Map();
let uploadButtonCounter = 0;
let dragDropCounter = 0;
let dragDropMoveCounter = 0;
let uploadSource = '';
let isHandlingDrop = false;
let lockedFolders = [];
let lockFeatureAvailable = true;

window.dragSelectState = {
    isSelecting: false,
    dragStarted: false,
    startedOnFileItem: false,
    startedOnSelectedItem: false
};

let wasDragging = false;
let isDraggingFile = false;

// DOM 요소 (init 함수 등에서 동적으로 할당될 수 있도록 let 사용)
let fileView = null;
let breadcrumb = null;
let createFolderBtn = null;
let folderModal = null;
let folderNameInput = null;
let createFolderConfirmBtn = null;
let cancelFolderBtn = null;
let fileUploadInput = null;
let cutBtn = null;
let pasteBtn = null;
let renameBtn = null;
let deleteBtn = null;
let renameModal = null;
let newNameInput = null;
let confirmRenameBtn = null;
let cancelRenameBtn = null;
let searchInput = null;
let loadingOverlay = null; // show/hideLoading에서 사용
let selectionBox = null;
let dropZone = null;
let progressContainer = null;
let progressBar = null;
let uploadStatus = null;
let fileList = null;
let contextMenu = null;
let statusbar = null;
let statusInfo = null;
let selectionInfo = null;
let gridViewBtn = null;
let listViewBtn = null;
let downloadBtn = null;

// *** showLoading / hideLoading 함수 정의 추가 ***
// 로딩 표시
function showLoading() {
    // loadingOverlay 요소가 없으면 가져옴
    if (!loadingOverlay) {
        loadingOverlay = document.getElementById('loadingOverlay');
    }
    if (loadingOverlay) {
        loadingOverlay.style.display = 'flex';
    } else {
        console.error('[showLoading] loadingOverlay 요소를 찾을 수 없습니다!');
    }
}

// 로딩 숨김
function hideLoading() {
    // loadingOverlay 요소가 없으면 가져옴
    if (!loadingOverlay) {
        loadingOverlay = document.getElementById('loadingOverlay');
    }
    if (loadingOverlay) {
        loadingOverlay.style.display = 'none';
    } else {
        console.error('[hideLoading] loadingOverlay 요소를 찾을 수 없습니다!');
    }
}
// *** 함수 정의 추가 끝 ***


// currentPath를 window 객체에 동기화하는 함수
function syncCurrentPath(path) {
    currentPath = path;
    window.currentPath = path;
    console.log(`[Path Updated] 현재 경로 업데이트: ${path || "루트"}`);
    return path;
}

// 상황에 맞는 버튼 비활성화/활성화 함수
function updateButtonStates() {
    const selectedCount = selectedItems.size;
    
    // 버튼 요소 가져오기 (없으면 DOM에서 찾기)
    if (!renameBtn) renameBtn = document.getElementById('renameBtn');
    if (!deleteBtn) deleteBtn = document.getElementById('deleteBtn');
    if (!cutBtn) cutBtn = document.getElementById('cutBtn');
    if (!downloadBtn) downloadBtn = document.getElementById('downloadBtn');
    if (!pasteBtn) pasteBtn = document.getElementById('pasteBtn');
    if (!statusbar) statusbar = document.getElementById('statusbar');
    if (statusbar && !selectionInfo) selectionInfo = statusbar.querySelector('.selection-info');
    if (!contextMenu) contextMenu = document.getElementById('contextMenu');

    if (renameBtn) renameBtn.disabled = selectedCount !== 1;
    if (deleteBtn) deleteBtn.disabled = selectedCount === 0;
    if (cutBtn) cutBtn.disabled = selectedCount === 0;
    if (downloadBtn) downloadBtn.disabled = selectedCount === 0;
    if (pasteBtn) pasteBtn.disabled = clipboardItems.length === 0;
    
    if (selectionInfo) selectionInfo.textContent = `${selectedCount}개 선택됨`;
    
    // 컨텍스트 메뉴 항목 업데이트
    if (contextMenu) {
        const ctxRename = document.getElementById('ctxRename');
        const ctxPaste = document.getElementById('ctxPaste');
        const ctxCut = document.getElementById('ctxCut');
        const ctxDelete = document.getElementById('ctxDelete');
        const ctxDownload = document.getElementById('ctxDownload');
        const ctxOpen = document.getElementById('ctxOpen');
        const ctxLock = document.getElementById('ctxLock'); // 추가

        if (ctxRename) ctxRename.style.display = selectedCount === 1 ? 'flex' : 'none';
        if (ctxPaste) ctxPaste.style.display = clipboardItems.length > 0 ? 'flex' : 'none';
        if (ctxCut) ctxCut.style.display = selectedCount > 0 ? 'flex' : 'none';
        if (ctxDelete) ctxDelete.style.display = selectedCount > 0 ? 'flex' : 'none';
        if (ctxDownload) ctxDownload.style.display = selectedCount > 0 ? 'flex' : 'none';
        if (ctxOpen) ctxOpen.style.display = selectedCount === 1 ? 'flex' : 'none';
        if (ctxLock) {
           // 잠금 메뉴 표시는 컨텍스트 메뉴 열릴 때 결정 (여기서는 일단 숨김)
           // 폴더가 선택되었는지 여부는 여기서는 알기 어려움
           // ctxLock.style.display = 'none'; 
        }
    }
}

// 모든 선택 해제
function clearSelection() {
    document.querySelectorAll('.file-item.selected, .file-item-grid.selected').forEach(item => {
        item.classList.remove('selected');
    });
    selectedItems.clear();
    updateButtonStates();
}

// 항목 선택 함수
function selectItem(fileItem) {
    const itemName = fileItem.getAttribute('data-name');
    fileItem.classList.add('selected');
    selectedItems.add(itemName);
    updateButtonStates();
}

// 항목 선택 토글 함수
function toggleSelection(fileItem) {
    const itemName = fileItem.getAttribute('data-name');
    if (fileItem.classList.contains('selected')) {
        fileItem.classList.remove('selected');
        selectedItems.delete(itemName);
    } else {
        fileItem.classList.add('selected');
        selectedItems.add(itemName);
    }
    updateButtonStates();
}

// Shift 키를 이용한 범위 선택 함수 - 구현 필요
function handleShiftSelect(fileItem) {
    // ... (로직 구현) ...
    clearSelection();
    selectItem(fileItem);
}

// 모달 초기화
function initModals() {
    // 요소 가져오기
    folderModal = document.getElementById('folderModal');
    renameModal = document.getElementById('renameModal');

    document.querySelectorAll('.modal-close').forEach(closeBtn => {
        closeBtn.addEventListener('click', () => {
            if(folderModal) folderModal.style.display = 'none';
            if(renameModal) renameModal.style.display = 'none';
        });
    });
    
    window.addEventListener('click', (e) => {
        if (e.target === folderModal) folderModal.style.display = 'none';
        if (e.target === renameModal) renameModal.style.display = 'none';
    });
    
    window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (folderModal && folderModal.style.display === 'flex') folderModal.style.display = 'none';
            if (renameModal && renameModal.style.display === 'flex') renameModal.style.display = 'none';
        }
    });
}


// 컨텍스트 메뉴 초기화
function initContextMenu() {
    contextMenu = document.getElementById('contextMenu');
    fileView = document.getElementById('fileView'); // fileView 할당

    if (!contextMenu || !fileView) {
        console.error("[ContextMenu] Cannot initialize: contextMenu or fileView not found.");
        return;
    }

    document.addEventListener('click', () => {
        if(contextMenu) contextMenu.style.display = 'none';
    });
    
    fileView.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        
        const fileItem = e.target.closest('.file-item, .file-item-grid');
        if (fileItem) {
            if (!fileItem.classList.contains('selected')) {
                clearSelection();
                selectItem(fileItem);
            }
            
            // 메뉴 항목 가져오기
            const ctxOpen = document.getElementById('ctxOpen');
            const ctxDownload = document.getElementById('ctxDownload');
            const ctxLock = document.getElementById('ctxLock');
            const ctxRename = document.getElementById('ctxRename'); // 추가
            const ctxPaste = document.getElementById('ctxPaste');   // 추가
            const ctxCut = document.getElementById('ctxCut');     // 추가
            const ctxDelete = document.getElementById('ctxDelete'); // 추가
            
            // 파일 타입 및 상태에 따른 메뉴 업데이트
            const isFolder = fileItem.getAttribute('data-is-folder') === 'true';
            const itemName = fileItem.getAttribute('data-name');
            const itemPath = currentPath ? `${currentPath}/${itemName}` : itemName;
            const selectedCount = selectedItems.size;

            // 공통 메뉴 상태 업데이트
            if(ctxRename) ctxRename.style.display = selectedCount === 1 ? 'flex' : 'none';
            if(ctxPaste) ctxPaste.style.display = clipboardItems.length > 0 ? 'flex' : 'none';
            if(ctxCut) ctxCut.style.display = selectedCount > 0 ? 'flex' : 'none';
            if(ctxDelete) ctxDelete.style.display = selectedCount > 0 ? 'flex' : 'none';
            if(ctxDownload) ctxDownload.style.display = selectedCount > 0 ? 'flex' : 'none'; 
            if(ctxOpen) ctxOpen.style.display = selectedCount === 1 ? 'flex' : 'none';
            
            if (isFolder) {
                if(ctxOpen) ctxOpen.innerHTML = '<i class="fas fa-folder-open"></i> 열기';
                if(ctxDownload) ctxDownload.innerHTML = '<i class="fas fa-download"></i> 다운로드'; // 폴더 다운로드
                if(ctxLock) {
                    ctxLock.style.display = lockFeatureAvailable ? 'flex' : 'none'; // 기능 활성화 시 표시
                    if (isPathLocked(itemPath)) {
                        ctxLock.innerHTML = '<i class="fas fa-unlock"></i> 잠금 해제';
                    } else {
                        ctxLock.innerHTML = '<i class="fas fa-lock"></i> 잠금';
                    }
                }
            } else {
                if(ctxOpen) ctxOpen.innerHTML = '<i class="fas fa-external-link-alt"></i> 미리보기'; // 파일은 미리보기로
                if(ctxDownload) ctxDownload.innerHTML = '<i class="fas fa-download"></i> 다운로드';
                if(ctxLock) ctxLock.style.display = 'none'; // 파일 잠금 메뉴 숨김
            }
            
            // 메뉴 위치 설정
            const menuWidth = contextMenu.offsetWidth;
            const menuHeight = contextMenu.offsetHeight;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            let left = e.clientX;
            let top = e.clientY;

            if (left + menuWidth > windowWidth) {
                left = windowWidth - menuWidth - 5; 
            }
            if (top + menuHeight > windowHeight) {
                top = windowHeight - menuHeight - 5;
            }
            
            contextMenu.style.left = `${left}px`;
            contextMenu.style.top = `${top}px`;
            contextMenu.style.display = 'block';
        } else {
            // 빈 공간 우클릭 시
            contextMenu.style.display = 'none'; 
            clearSelection();
            
            // 빈 공간 메뉴 (붙여넣기, 새폴더 등) - 필요시 활성화
            // const ctxPaste = document.getElementById('ctxPaste');
            // if(ctxPaste) ctxPaste.style.display = clipboardItems.length > 0 ? 'flex' : 'none';
            // ...
        }
    });
}

// 자동 스크롤 관련 변수
let autoScrollInterval = null;
let autoScrollSpeed = 0;
let autoScrollAnimationId = null; 

// 자동 스크롤 함수
function autoScroll(clientX, clientY) {
    if (!window.dragSelectState.isSelecting || !window.dragSelectState.dragStarted) {
        cancelAutoScroll();
        return;
    }
    
    const fileList = document.getElementById('fileList');
    const rect = fileList.getBoundingClientRect();
    const threshold = 50; // 가장자리 감지 임계값 (픽셀)
    const maxSpeed = 20; // 최대 스크롤 속도
    let scrollAmountY = 0;
    let scrollAmountX = 0;

    // 상단 가장자리
    if (clientY < rect.top + threshold) {
        scrollAmountY = -maxSpeed * ((threshold - (clientY - rect.top)) / threshold);
    }
    // 하단 가장자리
    else if (clientY > rect.bottom - threshold) {
        scrollAmountY = maxSpeed * ((threshold - (rect.bottom - clientY)) / threshold);
    }

    // 왼쪽 가장자리
    if (clientX < rect.left + threshold) {
        scrollAmountX = -maxSpeed * ((threshold - (clientX - rect.left)) / threshold);
    }
    // 오른쪽 가장자리
    else if (clientX > rect.right - threshold) {
        scrollAmountX = maxSpeed * ((threshold - (rect.right - clientX)) / threshold);
    }

    if (scrollAmountY !== 0 || scrollAmountX !== 0) {
        fileList.scrollTop += scrollAmountY;
        fileList.scrollLeft += scrollAmountX;
        
        // 스크롤 중에도 선택 영역 업데이트 (mousemove 이벤트 핸들러 호출 효과)
        // 가상 mousemove 이벤트 생성 또는 직접 선택 로직 호출 필요
        // 여기서는 간략하게 처리. 실제로는 handleMouseMove 내 선택 로직 재호출 필요
        handleMouseMove({clientX: clientX, clientY: clientY, ctrlKey: false}); // ctrlKey 상태 전달 필요
        
        // 다음 프레임에서 계속 스크롤
        autoScrollAnimationId = requestAnimationFrame(() => autoScroll(clientX, clientY));
    } else {
        // 스크롤 영역 벗어나면 중지
        cancelAutoScroll();
    }
}

// 자동 스크롤 취소 함수
function cancelAutoScroll() {
    if (autoScrollAnimationId !== null) {
        cancelAnimationFrame(autoScrollAnimationId);
        autoScrollAnimationId = null;
    }
}

// handleMouseDown, handleMouseMove, handleMouseUp 등 이전 수정된 함수 내용 포함
// ... (handleMouseDown, handleMouseMove, handleMouseUp 함수 정의 - 이전 단계에서 수정된 내용) ...
function handleMouseDown(e) {
    // 컨텍스트 메뉴, 또는 다른 상호작용 요소에서 시작된 이벤트는 무시
    if (e.target.closest('.context-menu') || e.button !== 0 ||
        e.target.closest('button') || e.target.closest('input') ||
        e.target.closest('select') || e.target.closest('a') ||
        e.target.closest('.modal') || e.target.closest('.dropdown-menu') ||
        e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' ||
        e.target.tagName === 'SELECT' || e.target.tagName === 'A') {
        return;
    }

    // 자동 스크롤 취소
    cancelAutoScroll();

    let startClientX = e.clientX;
    let startClientY = e.clientY;
    let originalTarget = e.target;

    // 파일 아이템 위에서 시작되었는지 확인
    const fileItemElement = e.target.closest('.file-item') || e.target.closest('.file-item-grid');

    // *** 수정된 로직 시작 ***
    window.dragSelectState.startedOnFileItem = fileItemElement !== null;
    window.dragSelectState.startedOnSelectedItem = false; // 초기화
    isDraggingFile = false; // 파일 드래그 플래그 초기화
    if (window.dragSelectState.startedOnFileItem) {
        if (fileItemElement.classList.contains('selected')) {
            window.dragSelectState.startedOnSelectedItem = true;
        }
        // 파일 아이템 draggable 속성 확인 (파일 드래그 시작 판별)
        if (fileItemElement.hasAttribute('draggable') && fileItemElement.getAttribute('draggable') === 'true') {
           // 실제 파일 드래그 시작은 dragstart 이벤트에서 판별하므로 여기선 isSelecting만 제어
           // isDraggingFile 플래그는 dragstart에서 설정
        }
    }
    // *** 수정된 로직 끝 ***

    // 파일 아이템 외부 클릭 시 (드래그 시작 전에 선택 해제하지 않음)

    // 파일 아이템 클릭 시 선택 처리 (선택되지 않은 항목 위)
    if (fileItemElement && !window.dragSelectState.startedOnSelectedItem) {
        if (!e.ctrlKey) {
            clearSelection();
        }
        toggleSelection(fileItemElement);
    }

    // selectionBox 로직은 파일 아이템 외부에서 시작 시에만 초기화
    if (!window.dragSelectState.startedOnFileItem) {
        e.preventDefault(); // 기본 텍스트 선택 등 방지

        window.dragSelectState.dragStarted = false;
        window.dragSelectState.isSelecting = true; // 마우스 누르는 순간 isSelecting은 true

        const initialScrollTop = fileList.scrollTop;
        const initialScrollLeft = fileList.scrollLeft;

        const selectionBox = document.getElementById('selectionBox');
        selectionBox.style.position = 'fixed';
        selectionBox.style.left = `${startClientX}px`;
        selectionBox.style.top = `${startClientY}px`;
        selectionBox.style.width = '0px';
        selectionBox.style.height = '0px';
        selectionBox.style.display = 'none';
        selectionBox.style.zIndex = '9999';

        selectionBox.dataset.startClientX = startClientX;
        selectionBox.dataset.startClientY = startClientY;
        selectionBox.dataset.initialScrollTop = initialScrollTop;
        selectionBox.dataset.initialScrollLeft = initialScrollLeft;

        wasDragging = false; // 드래그 선택 시작 여부 플래그
    } else {
         window.dragSelectState.isSelecting = false; // 파일 아이템 위에서 시작하면 isSelecting = false
    }
}


function handleMouseMove(e) {
    // *** 수정된 조건: 파일 드래그 중이거나, 선택 상태가 아니면 리턴 ***
    if (isDraggingFile || !window.dragSelectState.isSelecting) {
        return;
    }

    // isSelecting 이 true 이고, startedOnFileItem이 false 일 때만 selectionBox 로직 실행됨

    const fileList = document.getElementById('fileList');
    const selectionBox = document.getElementById('selectionBox');
    const rect = fileList.getBoundingClientRect();

    // selectionBox 데이터 가져오기 (데이터가 없으면 리턴 - handleMouseDown에서 설정 안된 경우)
    const startClientXStr = selectionBox.dataset.startClientX;
    const startClientYStr = selectionBox.dataset.startClientY;
    if (!startClientXStr || !startClientYStr) return;

    const startClientX = parseFloat(startClientXStr);
    const startClientY = parseFloat(startClientYStr);
    const initialScrollTop = parseFloat(selectionBox.dataset.initialScrollTop);
    const initialScrollLeft = parseFloat(selectionBox.dataset.initialScrollLeft || 0);

    const currentClientX = e.clientX;
    const currentClientY = e.clientY;

    const dragDistanceX = Math.abs(currentClientX - startClientX);
    const dragDistanceY = Math.abs(currentClientY - startClientY);
    const dragDistance = Math.sqrt(dragDistanceX * dragDistanceX + dragDistanceY * dragDistanceY);
    const minDragDistance = 10; // 최소 드래그 거리

    // 최소 드래그 거리를 넘으면 드래그 선택 시작
    if (!window.dragSelectState.dragStarted && dragDistance >= minDragDistance) {
        window.dragSelectState.dragStarted = true;
        wasDragging = true; // 드래그 선택 시작 플래그

        selectionBox.style.display = 'block'; // 선택 박스 표시

        // Ctrl 키가 눌려있지 않으면 선택 해제 (드래그 시작 시점)
        if (!e.ctrlKey) {
             clearSelection();
        }
    }

    if (!window.dragSelectState.dragStarted) return; // 드래그 시작 안됐으면 이후 로직 실행 안함

    // 선택 박스 위치 계산
    const left = Math.min(currentClientX, startClientX);
    const top = Math.min(currentClientY, startClientY);
    const width = Math.abs(currentClientX - startClientX);
    const height = Math.abs(currentClientY - startClientY);

    selectionBox.style.left = `${left}px`;
    selectionBox.style.top = `${top}px`;
    selectionBox.style.width = `${width}px`;
    selectionBox.style.height = `${height}px`;

    // 파일 항목 선택 로직 (스크롤 고려)
    const currentScrollTop = fileList.scrollTop;
    const currentScrollLeft = fileList.scrollLeft;
    const scrollDiffY = currentScrollTop - initialScrollTop;
    const scrollDiffX = currentScrollLeft - initialScrollLeft;

    const selectLeft = Math.min(currentClientX, startClientX) - rect.left + scrollDiffX;
    const selectRight = Math.max(currentClientX, startClientX) - rect.left + scrollDiffX;
    const startY_abs = startClientY - rect.top + initialScrollTop;
    const currentY_abs = currentClientY - rect.top + currentScrollTop;
    const selectTop = Math.min(startY_abs, currentY_abs);
    const selectBottom = Math.max(startY_abs, currentY_abs);

    // 자동 스크롤 처리
     // ... (autoScroll 로직 유지) ...
     if (currentClientY < rect.top + threshold || currentClientY > rect.bottom - threshold ||
         currentClientX < rect.left + threshold || currentClientX > rect.right - threshold) {
         if (autoScrollAnimationId === null) {
             autoScroll(currentClientX, currentClientY);
         }
     } else {
         cancelAutoScroll();
     }

    // 파일 항목 겹침 확인 및 선택 상태 업데이트
    const items = document.querySelectorAll('.file-item, .file-item-grid'); // 그리드 항목 포함
    items.forEach(item => {
        if (item.getAttribute('data-parent-dir') === 'true') return; // 상위 폴더 제외

        const itemRect = item.getBoundingClientRect();
        const itemLeft = itemRect.left - rect.left + fileList.scrollLeft;
        const itemTop = itemRect.top - rect.top + fileList.scrollTop;
        const itemRight = itemLeft + itemRect.width;
        const itemBottom = itemTop + itemRect.height;

        const overlap = !(itemRight < selectLeft || itemLeft > selectRight || itemBottom < selectTop || itemTop > selectBottom);

        // Ctrl 키 상태 고려하여 선택 상태 업데이트
        if (overlap) {
            if (!item.classList.contains('selected')) {
                item.classList.add('selected');
                selectedItems.add(item.getAttribute('data-name'));
            }
        } else {
            // 겹치지 않는 경우, Ctrl키가 눌려있지 않으면 선택 해제
            if (!e.ctrlKey && item.classList.contains('selected')) {
                item.classList.remove('selected');
                selectedItems.delete(item.getAttribute('data-name'));
            }
        }
    });
    updateButtonStates(); // 버튼 상태 업데이트
}


function handleMouseUp(e) {
    // 파일 이동을 위한 드래그였는지 확인 (mousemove에서 설정된 wasDragging 플래그 사용)
    const didDragSelect = wasDragging;
    wasDragging = false; // 플래그 리셋

    // 자동 스크롤 취소
    cancelAutoScroll();

    if (window.dragSelectState.isSelecting) {
        window.dragSelectState.isSelecting = false;

        const selectionBox = document.getElementById('selectionBox');
        selectionBox.style.width = '0px';
        selectionBox.style.height = '0px';
        selectionBox.style.display = 'none';

        // 클릭 이벤트 처리 (드래그 선택이 아닌 경우)
        if (!didDragSelect && e.button === 0) {
            const fileItem = e.target.closest('.file-item') || e.target.closest('.file-item-grid');
            if (fileItem) {
                // 파일 항목 클릭 시 처리 (이미 handleMouseDown에서 처리됨, 필요시 추가 로직)
            } else {
                // 파일 목록의 빈 공간 클릭 시 선택 해제
                if (!e.ctrlKey) { // Ctrl 키 누르지 않았을 때만 해제
                    clearSelection();
                }
            }
        }
        updateButtonStates(); // 최종 버튼 상태 업데이트
    }

    // 드래그 상태 초기화
    window.dragSelectState.startedOnFileItem = false;
    window.dragSelectState.startedOnSelectedItem = false;
    window.dragSelectState.dragStarted = false;
    isDraggingFile = false; // 파일 드래그 플래그 리셋
}


// 파일 드래그 시작 이벤트 핸들러 추가
function handleFileDragStart(e) {
    const fileItem = e.target.closest('.file-item[draggable="true"], .file-item-grid[draggable="true"]');
    if (!fileItem) return;

    isDraggingFile = true; // 파일 드래그 시작 플래그 설정
    console.log('[Drag] File drag started');

    // 선택되지 않은 항목을 드래그 시작하면 해당 항목만 선택
    if (!selectedItems.has(fileItem.getAttribute('data-name'))) {
        clearSelection();
        selectItem(fileItem);
    }

    // 드래그 데이터 설정
    const itemsToDrag = Array.from(selectedItems);
    try {
        e.dataTransfer.setData('application/json', JSON.stringify({
            sourcePath: currentPath,
            items: itemsToDrag
        }));
        e.dataTransfer.effectAllowed = 'move'; // 또는 'copyMove'
    } catch (err) {
        console.error("Error setting drag data:", err);
        // IE 등 구형 브라우저 호환성 처리 필요 시
        // e.dataTransfer.setData('Text', JSON.stringify(...));
    }

    // 드래그 중인 항목들에 시각적 효과 적용 (약간 지연 후 적용하여 깜빡임 방지)
    setTimeout(() => {
        document.querySelectorAll('.file-item.selected, .file-item-grid.selected').forEach(item => {
             if (item.closest && item.closest('.dragging') === null) { // 이미 dragging 클래스가 없으면 추가
                 item.classList.add('dragging');
             }
        });
    }, 0);
}

// 파일 드래그 종료 이벤트 핸들러 (성공 여부 관계 없이 호출됨)
function handleFileDragEnd(e) {
    console.log('[Drag] File drag ended');
    isDraggingFile = false; // 파일 드래그 종료 플래그 리셋

    // 드래그 시각적 효과 제거
    document.querySelectorAll('.dragging').forEach(item => {
        item.classList.remove('dragging');
    });
    clearAllDragOverClasses(); // 드래그 오버 하이라이트 제거
}

// 파일 드래그 엔터 (다른 요소 위로 들어갈 때)
function handleFileDragEnter(e) {
    e.preventDefault();
    e.stopPropagation();
    // console.log('[Drag] Enter:', e.target);

     // 드롭 가능한 대상인지 확인하고 스타일 적용 (예: 폴더)
     const potentialTarget = e.target.closest('.file-item[data-is-folder="true"], .file-item-grid[data-is-folder="true"]');
     const currentTarget = e.currentTarget; // 이벤트가 부착된 요소

     // 드래그 중인 항목 위는 무시
     if (potentialTarget && potentialTarget.classList.contains('dragging')) return;

     if (potentialTarget) { // 폴더 위
        clearAllDragOverClasses();
        potentialTarget.classList.add('drag-over');
     } else if (currentTarget === fileList) { // 파일 목록 빈 공간 위
         clearAllDragOverClasses();
         fileList.classList.add('drag-over-list');
     }
}

// 파일 드래그 오버 (요소 위에 머무를 때)
function handleFileDragOver(e) {
    e.preventDefault(); // 필수: 드롭 허용
    e.stopPropagation();
    e.dataTransfer.dropEffect = 'move'; // 드롭 효과 설정

    // 스타일링은 dragenter에서 처리되므로 여기서는 dropEffect만 설정해도 무방
    // 성능을 위해 매번 classList 조작은 피할 수 있음
    // 단, dragenter가 항상 먼저 발생한다는 보장이 없다면 여기서도 처리 필요
    const potentialTarget = e.target.closest('.file-item[data-is-folder="true"], .file-item-grid[data-is-folder="true"]');
    if (potentialTarget && !potentialTarget.classList.contains('dragging')) {
        if (!potentialTarget.classList.contains('drag-over')) {
            clearAllDragOverClasses();
            potentialTarget.classList.add('drag-over');
        }
    } else if (e.currentTarget === fileList) {
        if (!fileList.classList.contains('drag-over-list')) {
            clearAllDragOverClasses();
            fileList.classList.add('drag-over-list');
        }
    }
}

// 파일 드래그 리브 (요소 밖으로 나갈 때)
function handleFileDragLeave(e) {
    e.preventDefault();
    e.stopPropagation();

    const relatedTarget = e.relatedTarget;
    const currentTarget = e.currentTarget;

    // 마우스가 currentTarget의 자식 요소 안으로 이동한 경우 leave가 아님
    if (relatedTarget && currentTarget.contains(relatedTarget)) {
        return;
    }

    // console.log('[Drag] Leave:', e.currentTarget);
    // 해당 요소의 drag-over 클래스 제거
    if (currentTarget.classList.contains('drag-over')) {
        currentTarget.classList.remove('drag-over');
    }
    if (currentTarget === fileList && fileList.classList.contains('drag-over-list')) {
         fileList.classList.remove('drag-over-list');
    }
}

// 드롭 이벤트 핸들러 (파일 또는 폴더에 드롭 시)
function handleFileDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    console.log('[Drop] File dropped on item');
    const currentTarget = e.currentTarget; // 이벤트 리스너가 부착된 요소
    clearAllDragOverClasses(); // 하이라이트 제거
    isDraggingFile = false; // 드롭 완료 시 플래그 리셋

    const targetName = currentTarget.getAttribute('data-name');
    const isTargetFolder = currentTarget.getAttribute('data-is-folder') === 'true';

    if (!isTargetFolder) {
        console.log('[Drop] Target is not a folder.');
        return; // 폴더에만 드롭 허용
    }

    // 잠긴 폴더 확인
    const targetPath = currentPath ? `${currentPath}/${targetName}` : targetName;
    if (isPathLocked(targetPath)) {
        showToast(`잠긴 폴더 '${targetName}'(으)로는 파일을 이동하거나 드롭할 수 없습니다.`, 'warning');
        return;
    }

    try {
        const dataString = e.dataTransfer.getData('application/json');
        if (!dataString) {
             // 외부 파일 드롭 처리
             if (window.handleExternalFileDrop) {
                  console.log('[Drop] No internal data, handling as external file drop.');
                  window.handleExternalFileDrop(e, currentTarget);
             } else {
                  console.warn('[Drop] No data found in dataTransfer.');
             }
             return;
        }
        
        const data = JSON.parse(dataString);
        const sourcePath = data.sourcePath;
        const itemsToMove = data.items;

        if (!itemsToMove || itemsToMove.length === 0) {
            console.warn('[Drop] No items to move found in parsed data.');
            return;
        }

        // 자기 자신 또는 하위 폴더로 이동 방지
        if (itemsToMove.includes(targetName) || isSubdirectory(sourcePath, currentPath, itemsToMove, targetName)) {
             showToast('자기 자신 또는 하위 폴더로는 이동할 수 없습니다.', 'warning');
             return;
        }

        // 파일 이동 실행
        moveItems(itemsToMove, sourcePath, targetPath);

    } catch (error) {
        console.error('[Drop] Error handling drop on item:', error);
        // 오류 발생 시에도 외부 드롭 시도 (데이터 파싱 실패 등)
         if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length > 0 && window.handleExternalFileDrop) {
            console.log('[Drop] Error handling internal drop, attempting external drop.');
            window.handleExternalFileDrop(e, currentTarget);
         } else {
            showToast('파일을 처리하는 중 오류가 발생했습니다.', 'error');
        }
    }
}

// 파일 목록 빈 공간 드롭 핸들러
function handleFileListDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    console.log('[Drop] File dropped on file list area');
    clearAllDragOverClasses();
    isDraggingFile = false;

    // 잠긴 폴더 확인 (현재 경로)
    if (isPathLocked(currentPath)) {
        showToast(`현재 폴더 '${currentPath || '루트'}'가 잠겨 있어 파일을 드롭할 수 없습니다.`, 'warning');
        return;
    }

     try {
        const dataString = e.dataTransfer.getData('application/json');
         if (!dataString) {
             // 외부 파일 드롭 처리
             if (window.handleExternalFileDrop) {
                 console.log('[Drop] No internal data, handling as external file drop on list.');
                 window.handleExternalFileDrop(e, null); // 대상 폴더 없음
             } else {
                 console.warn('[Drop] No data found in dataTransfer.');
             }
             return;
         }
         
        const data = JSON.parse(dataString);
        const sourcePath = data.sourcePath;
        const itemsToMove = data.items;

        if (!itemsToMove || itemsToMove.length === 0) {
            console.warn('[Drop] No items to move found in parsed data.');
            return;
        }

        // 현재 경로로 이동
        if (sourcePath !== currentPath) { // 같은 경로로 이동하는 것은 무시
           moveItems(itemsToMove, sourcePath, currentPath);
        } else {
            console.log("[Drop] Source and target paths are the same, move ignored.");
        }

    } catch (error) {
        console.error('[Drop] Error handling drop on file list:', error);
        // 오류 발생 시에도 외부 드롭 시도
         if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length > 0 && window.handleExternalFileDrop) {
            console.log('[Drop] Error handling internal drop, attempting external drop on list.');
            window.handleExternalFileDrop(e, null);
         } else {
             showToast('파일을 처리하는 중 오류가 발생했습니다.', 'error');
         }
    }
}


// 모든 드래그 오버 클래스 제거 함수
function clearAllDragOverClasses() {
    document.querySelectorAll('.drag-over').forEach(item => item.classList.remove('drag-over'));
    document.querySelectorAll('.drag-over-list').forEach(item => item.classList.remove('drag-over-list'));
}

// 드래그 앤 드롭 설정 함수
function setupDragDrop() {
    fileList = document.getElementById('fileList'); // fileList 할당
    if (!fileList) {
        console.error("fileList element not found for drag drop setup.");
        return;
    }

    // 기존 리스너 제거 후 추가 (중복 방지 강화)
    const removeAndAddListener = (element, event, handler) => {
        element.removeEventListener(event, handler);
        element.addEventListener(event, handler);
    };

    // 파일 목록 영역 리스너
    removeAndAddListener(fileList, 'dragleave', handleFileDragLeave);
    removeAndAddListener(fileList, 'drop', handleFileListDrop);
    // fileList 영역의 dragenter, dragover는 개별 항목에서 처리하도록 함 (버블링 방지 목적)
    removeAndAddListener(fileList, 'dragenter', (e) => { e.preventDefault(); handleFileDragEnter(e); }); // 기본 처리 + 커스텀 핸들러
    removeAndAddListener(fileList, 'dragover', (e) => { e.preventDefault(); handleFileDragOver(e); }); // 기본 처리 + 커스텀 핸들러

    // 개별 아이템 리스너
    const items = document.querySelectorAll('.file-item, .file-item-grid');
    items.forEach(item => {
        if (item.getAttribute('data-parent-dir') === 'true') {
             item.removeAttribute('draggable');
             return;
        }
        item.setAttribute('draggable', 'true');
        removeAndAddListener(item, 'dragstart', handleFileDragStart);
        removeAndAddListener(item, 'dragend', handleFileDragEnd);

        // 폴더만 드롭 대상
        if (item.getAttribute('data-is-folder') === 'true') {
            removeAndAddListener(item, 'dragenter', handleFileDragEnter);
            removeAndAddListener(item, 'dragover', handleFileDragOver);
            removeAndAddListener(item, 'dragleave', handleFileDragLeave);
            removeAndAddListener(item, 'drop', handleFileDrop);
        }
    });

    console.log(`[DragDrop] Setup complete for ${items.length} items.`);
}


// 이벤트 리스너 설정 (한 번만 실행되도록 구조 변경)
function setupEventListeners() {
    // DOM 요소 가져오기
    createFolderBtn = document.getElementById('createFolder');
    folderNameInput = document.getElementById('folderName');
    createFolderConfirmBtn = document.getElementById('createFolderBtn');
    cancelFolderBtn = document.getElementById('cancelFolderBtn');
    fileUploadInput = document.getElementById('fileUpload');
    cutBtn = document.getElementById('cutBtn');
    pasteBtn = document.getElementById('pasteBtn');
    renameBtn = document.getElementById('renameBtn');
    deleteBtn = document.getElementById('deleteBtn');
    newNameInput = document.getElementById('newName');
    confirmRenameBtn = document.getElementById('confirmRenameBtn');
    cancelRenameBtn = document.getElementById('cancelRenameBtn');
    searchInput = document.getElementById('searchInput');
    breadcrumb = document.getElementById('breadcrumb');
    fileView = document.getElementById('fileView');
    gridViewBtn = document.getElementById('gridViewBtn');
    listViewBtn = document.getElementById('listViewBtn');
    downloadBtn = document.getElementById('downloadBtn');

    // 이벤트 리스너 연결 (null 체크 추가)
    if (createFolderBtn) createFolderBtn.addEventListener('click', openCreateFolderModal);
    if (createFolderConfirmBtn) createFolderConfirmBtn.addEventListener('click', createFolder);
    if (cancelFolderBtn) cancelFolderBtn.addEventListener('click', () => folderModal.style.display = 'none');
    if (fileUploadInput) { 
        // upload.js에서 처리하므로 여기서는 제거 또는 조건부 처리
        // fileUploadInput.addEventListener('change', handleFileUpload);
    }
    if (cutBtn) cutBtn.addEventListener('click', cutSelected);
    if (pasteBtn) pasteBtn.addEventListener('click', pasteItems);
    if (renameBtn) renameBtn.addEventListener('click', openRenameModal);
    if (deleteBtn) deleteBtn.addEventListener('click', deleteSelected);
    if (confirmRenameBtn) confirmRenameBtn.addEventListener('click', renameItem);
    if (cancelRenameBtn) cancelRenameBtn.addEventListener('click', () => renameModal.style.display = 'none');
    if (searchInput) searchInput.addEventListener('input', handleSearch);
    if (gridViewBtn) gridViewBtn.addEventListener('click', () => switchView(false));
    if (listViewBtn) listViewBtn.addEventListener('click', () => switchView(true));
    if (downloadBtn) downloadBtn.addEventListener('click', downloadSelected);

    // Breadcrumb 이벤트 위임
    if (breadcrumb) {
        breadcrumb.addEventListener('click', (e) => {
            if (e.target.tagName === 'SPAN' && e.target.dataset.path !== undefined) {
                loadFiles(e.target.dataset.path);
            }
        });
    }
    
    // 파일 목록 클릭 이벤트 (이벤트 위임)
    if (fileView) {
        fileView.addEventListener('click', (e) => {
            const fileItem = e.target.closest('.file-item, .file-item-grid');
            if (fileItem) {
                const isFolder = fileItem.getAttribute('data-is-folder') === 'true';
                const itemName = fileItem.getAttribute('data-name');
                const parentDir = fileItem.getAttribute('data-parent-dir') === 'true';

                if (parentDir) {
                    // 상위 폴더 이동
                    const parentPath = currentPath.substring(0, currentPath.lastIndexOf('/'));
                    loadFiles(parentPath);
                } else if (e.detail === 2) { // 더블 클릭
                    if (isFolder) {
                        const newPath = currentPath ? `${currentPath}/${itemName}` : itemName;
                        loadFiles(newPath);
                    } else {
                        // 파일 미리보기 또는 다운로드
                        previewOrDownloadFile(itemName);
                    }
                } else { // 싱글 클릭
                    if (e.ctrlKey) {
                        toggleSelection(fileItem);
                    } else if (e.shiftKey) {
                        // Shift 선택 로직 (구현 필요)
                        handleShiftSelect(fileItem);
                    } else {
                        // 다른 항목 선택 해제 후 현재 항목 선택
                        clearSelection();
                        selectItem(fileItem);
                    }
                }
            } else {
                 // 빈 공간 클릭 시 선택 해제 (handleMouseUp에서 처리)
                 // if (!e.ctrlKey && !e.shiftKey) {
                 //     clearSelection();
                 // }
            }
        });
    }
    
    // 마우스 드래그 선택 이벤트 리스너 (document에 연결)
    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    // 키보드 단축키
    document.addEventListener('keydown', handleKeyDown);
    
    console.log("[EventListeners] Setup complete.");
}


// ... (파일 로드, 생성, 삭제, 이름 변경, 이동, 다운로드 등 나머지 함수들 정의) ...
// loadFiles, renderFiles, createFolder, openCreateFolderModal, deleteItems, deleteSelected, 
// openRenameModal, renameItem, cutSelected, copySelected, pasteItems, moveItems, 
// downloadSelected, previewOrDownloadFile, handleSearch, switchView, 
// checkLockFeatureAvailability, loadLockedFolders, toggleLockUI, isPathLocked, toggleLock 

async function loadFiles(path = '') {
    showLoading();
    clearSelection(); // 경로 변경 시 선택 해제
    currentPath = syncCurrentPath(path); // 전역 변수 및 window 객체 업데이트
    
    try {
        const response = await fetch(`${API_BASE_URL}/api/files/${encodeURIComponent(path)}`);
        if (!response.ok) {
            if (response.status === 404) {
                 showToast(`폴더를 찾을 수 없습니다: ${path || '루트'}`, 'error');
                 // 이전 경로로 돌아가거나 루트로 이동하는 로직 추가 가능
                 currentPath = syncCurrentPath(''); // 루트로 이동
                 await loadFiles(''); // 루트 로드 재시도
            } else {
                 throw new Error(`상태 ${response.status}: ${response.statusText}`);
            }
            return; // 오류 발생 시 아래 코드 실행 방지
        }
        const files = await response.json();
        
        // 파일 정보 맵 업데이트
        fileInfoMap.clear();
        files.forEach(file => fileInfoMap.set(file.name, file));
        
        renderFiles(files, path);
        updateBreadcrumb(path);
        
        // 디스크 사용량 정보 로드 (별도 함수)
        loadDiskUsage(); 
        
        // 파일 로드 후 드래그 앤 드롭 설정
        setupDragDrop();
        
    } catch (error) {
        console.error('파일 목록 로드 오류:', error);
        showToast(`파일 목록을 불러오는 데 실패했습니다: ${error.message}`, 'error');
        // 오류 발생 시 루트로 이동 시도
        if (path !== '') { // 현재 경로가 루트가 아닐 때만
            console.warn("Fallback to root directory due to error.");
            await loadFiles('');
        }
    } finally {
        hideLoading();
    }
}


// ... (renderFiles, updateBreadcrumb, loadDiskUsage 등 구현) ...


// 초기화 함수
async function init() {
    // DOM 요소 초기화 (여기서 한 번만 실행)
    fileView = document.getElementById('fileView');
    breadcrumb = document.getElementById('breadcrumb');
    // ... 나머지 DOM 요소들 ...
    loadingOverlay = document.getElementById('loadingOverlay'); 
    selectionBox = document.getElementById('selectionBox');
    fileList = document.getElementById('fileList');
    // ...

    showLoading();
    try {
        await checkLockFeatureAvailability();
        await loadLockedFolders();
        await loadFiles(currentPath); 
        toggleLockUI(lockFeatureAvailable);
        setupEventListeners(); 
        initModals();
        initContextMenu();

        if (typeof window.initializeUploader === 'function') {
            window.initializeUploader();
            console.log('[Init] Uploader initialized.');
        } else {
            console.warn('[Init] initializeUploader function not found.');
        }

        updateButtonStates();

    } catch (error) {
        console.error('초기화 중 오류 발생:', error);
        showToast('애플리케이션 초기화에 실패했습니다.', 'error');
    } finally {
        hideLoading();
    }
}

// 페이지 로드 시 초기화 실행
document.addEventListener('DOMContentLoaded', init);


// ... (나머지 유틸리티 함수 및 실제 기능 구현) ...

</rewritten_file> 