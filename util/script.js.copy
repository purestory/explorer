// 전역 변수
// URL 경로에 따라 적절한 API 베이스 URL 설정
const API_BASE_URL = window.location.hostname === 'itsmyzone.iptime.org' ? 
    window.location.origin : window.location.origin;
let currentPath = '';
let selectedItems = new Set();
let clipboardItems = [];
let clipboardOperation = ''; // 'cut' or 'copy'
let isDragging = false;
let startX, startY;
let listView = true; // 기본값을 true로 설정 (목록 보기)
let diskUsage = null;
// 정렬 상태 추가
let sortField = 'name'; // 정렬 필드: name, size, date
let sortDirection = 'asc'; // 정렬 방향: asc, desc
// 파일 정보 저장을 위한 맵 추가
let fileInfoMap = new Map();
// 업로드 함수 호출 카운터 추가
let uploadButtonCounter = 0;
let dragDropCounter = 0;
let dragDropMoveCounter = 0; // 드래그앤드롭 파일 이동 호출 카운터 추가
let uploadSource = ''; // 업로드 소스 추적 ('button' 또는 'dragdrop')
let isHandlingDrop = false; // 드롭 이벤트 중복 처리 방지 플래그 추가
// 폴더 잠금 상태 저장
let lockedFolders = [];
// 폴더 잠금 기능 사용 가능 여부
let lockFeatureAvailable = true;

// 드래그 선택 상태 관련 전역 변수 추가
window.dragSelectState = {
    isSelecting: false,
    dragStarted: false,
    startedOnFileItem: false,
    startedOnSelectedItem: false
};

// 파일 최상단 또는 적절한 전역 스코프에 추가
let wasDragging = false;

// DOM 요소
const fileView = document.getElementById('fileView');
const breadcrumb = document.getElementById('breadcrumb');
const createFolderBtn = document.getElementById('createFolder');
const folderModal = document.getElementById('folderModal');
const folderNameInput = document.getElementById('folderName');
const createFolderConfirmBtn = document.getElementById('createFolderBtn');
const cancelFolderBtn = document.getElementById('cancelFolderBtn');
const fileUploadInput = document.getElementById('fileUpload');
const cutBtn = document.getElementById('cutBtn');
const pasteBtn = document.getElementById('pasteBtn');
const renameBtn = document.getElementById('renameBtn');
const deleteBtn = document.getElementById('deleteBtn');
const renameModal = document.getElementById('renameModal');
const newNameInput = document.getElementById('newName');
const confirmRenameBtn = document.getElementById('confirmRenameBtn');
const cancelRenameBtn = document.getElementById('cancelRenameBtn');
const searchInput = document.getElementById('searchInput');
const loadingOverlay = document.getElementById('loadingOverlay');
const selectionBox = document.getElementById('selectionBox');
const dropZone = document.getElementById('dropZone');
const progressContainer = document.getElementById('progressContainer');
const progressBar = document.getElementById('progressBar');
const uploadStatus = document.getElementById('uploadStatus');
const fileList = document.getElementById('fileList');
const contextMenu = document.getElementById('contextMenu');
const statusbar = document.getElementById('statusbar');
const statusInfo = statusbar.querySelector('.status-info');
const selectionInfo = statusbar.querySelector('.selection-info');
const gridViewBtn = document.getElementById('gridViewBtn');
const listViewBtn = document.getElementById('listViewBtn');
const downloadBtn = document.getElementById('downloadBtn');

// UI에서 잘라내기, 붙여넣기, 이름변경 버튼 숨기기
cutBtn.style.display = 'none';
pasteBtn.style.display = 'none';
renameBtn.style.display = 'none';

// 상황에 맞는 버튼 비활성화/활성화 함수
function updateButtonStates() {
    const selectedCount = selectedItems.size;
    
    renameBtn.disabled = selectedCount !== 1;
    deleteBtn.disabled = selectedCount === 0;
    cutBtn.disabled = selectedCount === 0;
    downloadBtn.disabled = selectedCount === 0;
    
    // 붙여넣기 버튼은 클립보드에 항목이 있을 때만 활성화
    pasteBtn.disabled = clipboardItems.length === 0;
    
    // 상태바 업데이트
    selectionInfo.textContent = `${selectedCount}개 선택됨`;
    
    // 컨텍스트 메뉴 항목 업데이트
    document.getElementById('ctxRename').style.display = selectedCount === 1 ? 'flex' : 'none';
    document.getElementById('ctxPaste').style.display = clipboardItems.length > 0 ? 'flex' : 'none';
    document.getElementById('ctxCut').style.display = selectedCount > 0 ? 'flex' : 'none';
    document.getElementById('ctxDelete').style.display = selectedCount > 0 ? 'flex' : 'none';
    document.getElementById('ctxDownload').style.display = selectedCount > 0 ? 'flex' : 'none';
    document.getElementById('ctxOpen').style.display = selectedCount === 1 ? 'flex' : 'none';
}

// 모든 선택 해제
function clearSelection() {
    document.querySelectorAll('.file-item.selected, .file-item-grid.selected').forEach(item => {
        item.classList.remove('selected');
    });
    selectedItems.clear();
    updateButtonStates();
}

// 항목 선택 함수
function selectItem(fileItem) {
    const itemName = fileItem.getAttribute('data-name');
    fileItem.classList.add('selected');
    selectedItems.add(itemName);
    updateButtonStates();
}

// 항목 선택 토글 함수
function toggleSelection(fileItem) {
    const itemName = fileItem.getAttribute('data-name');
    if (fileItem.classList.contains('selected')) {
        fileItem.classList.remove('selected');
        selectedItems.delete(itemName);
    } else {
        fileItem.classList.add('selected');
        selectedItems.add(itemName);
    }
    updateButtonStates();
}

// Shift 키를 이용한 범위 선택 함수
function handleShiftSelect(fileItem) {
    // 구현 예정 - 필요에 따라 추가 가능
    // 현재는 단일 선택으로 처리
    clearSelection();
    selectItem(fileItem);
}

// 모달 초기화
function initModals() {
    // 모달 닫기 버튼
    document.querySelectorAll('.modal-close').forEach(closeBtn => {
        closeBtn.addEventListener('click', () => {
            folderModal.style.display = 'none';
            renameModal.style.display = 'none';
        });
    });
    
    // 배경 클릭 시 모달 닫기
    window.addEventListener('click', (e) => {
        if (e.target === folderModal) {
            folderModal.style.display = 'none';
        }
        if (e.target === renameModal) {
            renameModal.style.display = 'none';
        }
    });
    
    // ESC 키로 모달 닫기
    window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (folderModal.style.display === 'flex') {
                folderModal.style.display = 'none';
            }
            if (renameModal.style.display === 'flex') {
                renameModal.style.display = 'none';
            }
        }
    });
}

// 로딩 표시
function showLoading() {
    if (!loadingOverlay) { 
        loadingOverlay = document.getElementById('loadingOverlay');
    }
    if (loadingOverlay) {
        loadingOverlay.style.display = 'flex';
    } else {
        console.error('[showLoading] loadingOverlay 요소를 찾을 수 없습니다!');
    }
}

function hideLoading() {
    if (!loadingOverlay) {
        loadingOverlay = document.getElementById('loadingOverlay');
    }
    if (loadingOverlay) {
        loadingOverlay.style.display = 'none';
    } else {
        console.error('[hideLoading] loadingOverlay 요소를 찾을 수 없습니다!');
    }
}

// 컨텍스트 메뉴 초기화
function initContextMenu() {
    // 컨텍스트 메뉴 숨기기
    document.addEventListener('click', () => {
        contextMenu.style.display = 'none';
    });
    
    // 항목에 대한 컨텍스트 메뉴
    fileView.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        
        const fileItem = e.target.closest('.file-item');
        if (fileItem) {
            if (!fileItem.classList.contains('selected')) {
                clearSelection();
                selectItem(fileItem);
            }
            
            // 파일 타입에 따라 열기/다운로드 메뉴 표시 조정
            const isFolder = fileItem.getAttribute('data-is-folder') === 'true';
            const ctxOpen = document.getElementById('ctxOpen');
            const ctxDownload = document.getElementById('ctxDownload');
            const ctxLock = document.getElementById('ctxLock'); // 잠금 메뉴 항목
            
            if (isFolder) {
                ctxOpen.innerHTML = '<i class="fas fa-folder-open"></i> 열기';
                ctxDownload.style.display = 'flex'; // 폴더도 다운로드 메뉴 표시
                ctxDownload.innerHTML = '<i class="fas fa-download"></i> 다운로드'; // 폴더도 그냥 다운로드로 표시
                ctxLock.style.display = 'flex'; // 폴더인 경우에만 잠금 메뉴 표시
                
                // 경로 가져오기
                const itemName = fileItem.getAttribute('data-name');
                const itemPath = currentPath ? `${currentPath}/${itemName}` : itemName;
                
                // 잠금 상태에 따라 메뉴 텍스트 변경
                if (isPathLocked(itemPath)) {
                    ctxLock.innerHTML = '<i class="fas fa-unlock"></i> 잠금 해제';
                } else {
                    ctxLock.innerHTML = '<i class="fas fa-lock"></i> 잠금';
                }
            } else {
                ctxOpen.innerHTML = '<i class="fas fa-external-link-alt"></i> 열기';
                ctxDownload.style.display = 'flex';
                ctxDownload.innerHTML = '<i class="fas fa-download"></i> 다운로드'; // 일반 파일은 다운로드로 표시
                ctxLock.style.display = 'none'; // 파일인 경우 잠금 메뉴 숨김
            }
            
            // 압축 메뉴 표시
            document.getElementById('ctxCompress').style.display = 'flex';
            
            // 메뉴 표시
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${e.pageX}px`;
            contextMenu.style.top = `${e.pageY}px`;
            
            // 컨텍스트 메뉴가 화면 밖으로 나가는지 확인
            const menuRect = contextMenu.getBoundingClientRect();
            if (menuRect.right > window.innerWidth) {
                contextMenu.style.left = `${e.pageX - menuRect.width}px`;
            }
            if (menuRect.bottom > window.innerHeight) {
                contextMenu.style.top = `${e.pageY - menuRect.height}px`;
            }
        }
    });
    
    // 빈 공간에 대한 컨텍스트 메뉴
    fileList.addEventListener('contextmenu', (e) => {
        if (e.target === fileList || e.target === fileView) {
            e.preventDefault();
            clearSelection();
            
            // 메뉴 표시 (붙여넣기와 새 폴더 항목)
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${e.pageX}px`;
            contextMenu.style.top = `${e.pageY}px`;
            
            // 필요한 항목만 표시
            document.querySelectorAll('.context-menu-item').forEach(item => {
                item.style.display = 'none';
            });
            document.getElementById('ctxPaste').style.display = clipboardItems.length > 0 ? 'flex' : 'none';
            document.getElementById('ctxNewFolder').style.display = 'flex'; // 새 폴더 항목 표시
            
            // 컨텍스트 메뉴가 화면 밖으로 나가는지 확인
            const menuRect = contextMenu.getBoundingClientRect();
            if (menuRect.right > window.innerWidth) {
                contextMenu.style.left = `${e.pageX - menuRect.width}px`;
            }
            if (menuRect.bottom > window.innerHeight) {
                contextMenu.style.top = `${e.pageY - menuRect.height}px`;
            }
        }
    });
    
    // 컨텍스트 메뉴 항목 클릭 핸들러
    document.getElementById('ctxOpen').addEventListener('click', () => {
        const selectedItem = document.querySelector('.file-item.selected');
        if (!selectedItem) return;
        
        const isFolder = selectedItem.getAttribute('data-is-folder') === 'true';
        const fileName = selectedItem.getAttribute('data-name');
        
        if (isFolder) {
            // 폴더인 경우 열기
            navigateToFolder(fileName);
        } else {
            // 파일인 경우 열기 (브라우저에서 직접 열기)
            openFile(fileName);
        }
    });
    
    document.getElementById('ctxDownload').addEventListener('click', () => {
        downloadSelectedItems();
    });
    
    document.getElementById('ctxCut').addEventListener('click', cutSelectedItems);
    document.getElementById('ctxPaste').addEventListener('click', pasteItems);
    document.getElementById('ctxRename').addEventListener('click', showRenameDialog);
    document.getElementById('ctxDelete').addEventListener('click', deleteSelectedItems);
    
    // 폴더 잠금 토글 이벤트 추가 (수정)
    document.getElementById('ctxLock').addEventListener('click', (e) => {
        // 메뉴 텍스트에서 명령 확인 (잠금 또는 해제)
        const menuText = e.currentTarget.textContent.trim();
        const action = menuText.includes('잠금 해제') ? 'unlock' : 'lock';
        toggleFolderLock(action);
    });
    
    document.getElementById('ctxNewFolder').addEventListener('click', () => {
        // 현재 폴더에 존재하는 파일 목록 확인
        const fileItems = document.querySelectorAll('.file-item');
        const existingNames = Array.from(fileItems).map(item => item.getAttribute('data-name'));
        
        // 기본 폴더명 '새폴더'와 중복되지 않는 이름 찾기
        let defaultName = '새폴더';
        let counter = 1;
        
        while (existingNames.includes(defaultName)) {
            defaultName = `새폴더(${counter})`;
            counter++;
        }
        
        // 기본 폴더명 설정
        folderNameInput.value = defaultName;
        folderModal.style.display = 'flex';
        folderNameInput.focus();
        
        // 모든 텍스트를 선택하여 바로 수정할 수 있게 함
        folderNameInput.select();
    });
    
    // 압축 메뉴 이벤트 추가
    document.getElementById('ctxCompress').addEventListener('click', compressSelectedItems);
}

// 파일 열기 함수 (브라우저에서 직접 열기)
function openFile(fileName) {
    const filePath = currentPath ? `${currentPath}/${fileName}` : fileName;
    const encodedPath = encodeURIComponent(filePath);
    
    // 파일 확장자 확인
    const fileExt = fileName.split('.').pop().toLowerCase();
    
    // 브라우저에서 볼 수 있는 파일 확장자
    const viewableTypes = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 
                          'mp4', 'webm', 'ogg', 'mp3', 'wav', 
                          'pdf', 'txt', 'html', 'htm', 'css', 'js', 'json', 'xml'];
    
    // 브라우저에서 볼 수 있는 파일인 경우
    if (viewableTypes.includes(fileExt)) {
        // 직접 보기 모드로 URL 생성 (view=true 쿼리 파라미터 추가)
        const fileUrl = `${API_BASE_URL}/api/files/${encodedPath}?view=true`;
        
        // 새 창에서 열기
        window.open(fileUrl, '_blank');
        statusInfo.textContent = `${fileName} 파일 열기`;
    } else {
        // 브라우저에서 직접 볼 수 없는 파일은 다운로드
        statusInfo.textContent = `${fileName} 다운로드 중...`;
        
        // 다운로드 모드 URL (쿼리 파라미터 없음)
        const fileUrl = `${API_BASE_URL}/api/files/${encodedPath}`;
        
        // 원래 방식으로 복구
        const link = document.createElement('a');
        link.href = fileUrl;
        link.setAttribute('download', fileName); // 명시적으로 download 속성 설정
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        setTimeout(() => {
            statusInfo.textContent = `${fileName} 다운로드 완료`;
        }, 1000);
    }
}

// 파일 드래그 선택 초기화
function initDragSelect() {
    const fileList = document.getElementById('fileList');
    // 지역 변수 대신 전역 dragSelectState 객체 사용
    const minDragDistance = 5; // 최소 드래그 거리 (픽셀)
    
    // 자동 스크롤 관련 변수 추가
    let autoScrollAnimationId = null;
    const scrollSpeed = 8; // 스크롤 속도 (픽셀/프레임)
    const scrollEdgeSize = 80; // 스크롤 감지 영역 크기 (픽셀)
    
    // 자동 스크롤 함수
    function autoScroll(clientX, clientY) {
        if (!window.dragSelectState.isSelecting || !window.dragSelectState.dragStarted) {
            cancelAutoScroll();
            return;
        }
        
        const rect = fileList.getBoundingClientRect();
        let scrollX = 0;
        let scrollY = 0;
        
        // 수직 스크롤 계산
        if (clientY < rect.top + scrollEdgeSize) {
            // 상단 가장자리 근처에서는 위로 스크롤
            scrollY = -scrollSpeed * (1 - ((clientY - rect.top) / scrollEdgeSize));
        } else if (clientY > rect.bottom - scrollEdgeSize) {
            // 하단 가장자리 근처에서는 아래로 스크롤
            scrollY = scrollSpeed * (1 - ((rect.bottom - clientY) / scrollEdgeSize));
        }
        
        // 수평 스크롤 계산 (필요한 경우)
        if (clientX < rect.left + scrollEdgeSize) {
            // 왼쪽 가장자리 근처에서는 왼쪽으로 스크롤
            scrollX = -scrollSpeed * (1 - ((clientX - rect.left) / scrollEdgeSize));
        } else if (clientX > rect.right - scrollEdgeSize) {
            // 오른쪽 가장자리 근처에서는 오른쪽으로 스크롤
            scrollX = scrollSpeed * (1 - ((rect.right - clientX) / scrollEdgeSize));
        }
        
        // 스크롤 적용
        if (scrollY !== 0) {
            fileList.scrollTop += scrollY;
        }
        if (scrollX !== 0 && fileList.scrollWidth > fileList.clientWidth) {
            fileList.scrollLeft += scrollX;
        }
        
        // 다음 프레임에서 계속 스크롤
        autoScrollAnimationId = requestAnimationFrame(() => autoScroll(clientX, clientY));
    }
    
    // 자동 스크롤 취소 함수
    function cancelAutoScroll() {
        if (autoScrollAnimationId !== null) {
            cancelAnimationFrame(autoScrollAnimationId);
            autoScrollAnimationId = null;
        }
    }
    
    // 마우스 이벤트를 document에 연결 (화면 어디서나 드래그 가능하도록)
    document.addEventListener('mousedown', (e) => {
        // 컨텍스트 메뉴, 또는 다른 상호작용 요소에서 시작된 이벤트는 무시
        if (e.target.closest('.context-menu') || e.button !== 0
            || e.target.closest('button') || e.target.closest('input')
            || e.target.closest('select') || e.target.closest('a')
            || e.target.closest('.modal') || e.target.closest('.dropdown-menu')
            || e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT'
            || e.target.tagName === 'SELECT' || e.target.tagName === 'A') {
            return;
        }
        
        // 자동 스크롤 취소 (이전에 진행 중인 것이 있다면)
        cancelAutoScroll();
        
        // 초기 클라이언트 좌표 저장 (스크롤 위치와 무관)
        let startClientX = e.clientX;
        let startClientY = e.clientY;
        let originalTarget = e.target;
        
        // 파일 항목 위에서 시작되었는지 확인
        const fileItemElement = e.target.closest('.file-item') || e.target.closest('.file-item-grid');
        window.dragSelectState.startedOnFileItem = fileItemElement !== null;
        
        // 선택된 항목 위에서 시작된 경우 드래그 선택을 하지 않음 (파일 이동 우선)
        if (window.dragSelectState.startedOnFileItem && fileItemElement.classList.contains('selected')) {
            window.dragSelectState.startedOnSelectedItem = true;
            return; // 선택된 항목에서는 드래그 선택을 시작하지 않음
        }
        
        e.preventDefault();
        
        window.dragSelectState.dragStarted = false;
        
        // 초기 스크롤 위치 저장
        const initialScrollTop = fileList.scrollTop;
        const initialScrollLeft = fileList.scrollLeft; // 수평 스크롤 위치도 저장
        
        // Ctrl 키가 눌려있지 않으면 선택 해제 (아직 드래그 시작 전이므로 대기)
        
        window.dragSelectState.isSelecting = true;
        
        // 선택 박스 초기화 (아직 보이지 않음)
        const selectionBox = document.getElementById('selectionBox');
        selectionBox.style.position = 'fixed'; // fixed로 변경하여 스크롤과 무관하게 함
        selectionBox.style.left = `${startClientX}px`;
        selectionBox.style.top = `${startClientY}px`;
        selectionBox.style.width = '0px';
        selectionBox.style.height = '0px';
        selectionBox.style.display = 'none'; // 처음에는 숨김
        selectionBox.style.zIndex = '9999'; // 더 높은 z-index 설정
        
        // 시작 정보 저장
        selectionBox.dataset.startClientX = startClientX;
        selectionBox.dataset.startClientY = startClientY;
        selectionBox.dataset.initialScrollTop = initialScrollTop;
        selectionBox.dataset.initialScrollLeft = initialScrollLeft; // 수평 스크롤 위치도 저장

        // 드래그 플래그 초기화
        wasDragging = false;
    });
    
    // 마우스 이동 이벤트
    document.addEventListener('mousemove', (e) => {
        // 선택된 항목에서 시작된 경우 드래그 선택하지 않음 (파일 이동 우선)
        if (window.dragSelectState.startedOnSelectedItem) return;
        
        if (!window.dragSelectState.isSelecting) return;
        
        const fileList = document.getElementById('fileList');
        const selectionBox = document.getElementById('selectionBox');
        const rect = fileList.getBoundingClientRect();
        
        // 저장된 시작 클라이언트 좌표
        const startClientX = parseFloat(selectionBox.dataset.startClientX);
        const startClientY = parseFloat(selectionBox.dataset.startClientY);
        const initialScrollTop = parseFloat(selectionBox.dataset.initialScrollTop);
        const initialScrollLeft = parseFloat(selectionBox.dataset.initialScrollLeft || 0);
        
        // 현재 클라이언트 좌표
        const currentClientX = e.clientX;
        const currentClientY = e.clientY;
        
        // 이동 거리 계산
        const dragDistanceX = Math.abs(currentClientX - startClientX);
        const dragDistanceY = Math.abs(currentClientY - startClientY);
        const dragDistance = Math.sqrt(dragDistanceX * dragDistanceX + dragDistanceY * dragDistanceY);
        
        // 최소 드래그 거리를 넘으면 드래그 선택 시작
        if (!window.dragSelectState.dragStarted && dragDistance >= minDragDistance) {
            window.dragSelectState.dragStarted = true;
            // 드래그 시작 시 플래그 설정
            wasDragging = true;
            
            // 선택 박스 표시
            selectionBox.style.display = 'block';
            
            // Ctrl 키가 눌려있지 않으면 선택 해제
            if (!e.ctrlKey) {
                clearSelection();
            }
        }
        
        // 드래그가 시작되지 않았으면 더 이상 처리하지 않음
        if (!window.dragSelectState.dragStarted) return;
        
        // 선택 박스 위치 계산 (고정 위치 기반)
        const left = Math.min(currentClientX, startClientX);
        const top = Math.min(currentClientY, startClientY);
        const width = Math.abs(currentClientX - startClientX);
        const height = Math.abs(currentClientY - startClientY);
        
        // 선택 박스 업데이트 (fixed 위치)
        selectionBox.style.left = `${left}px`;
        selectionBox.style.top = `${top}px`;
        selectionBox.style.width = `${width}px`;
        selectionBox.style.height = `${height}px`;
        
        // 파일 항목 선택 로직 (스크롤 고려)
        // 선택 영역의 절대 좌표 계산 (스크롤 포함)
        const currentScrollTop = fileList.scrollTop;
        const currentScrollLeft = fileList.scrollLeft;
        const scrollDiffY = currentScrollTop - initialScrollTop;
        const scrollDiffX = currentScrollLeft - initialScrollLeft;
        
        // 선택 영역의 절대 위치 계산 (컨테이너 내부 좌표)
        const selectLeft = Math.min(currentClientX, startClientX) - rect.left + scrollDiffX;
        const selectRight = Math.max(currentClientX, startClientX) - rect.left + scrollDiffX;
        
        // 스크롤 방향에 관계없이 선택 영역의 시작과 끝 좌표 계산을 수정
        // 시작 위치의 Y 좌표를 스크롤 시작 위치 기준으로 계산
        const startY_abs = startClientY - rect.top + initialScrollTop;
        // 현재 위치의 Y 좌표를 현재 스크롤 위치 기준으로 계산
        const currentY_abs = currentClientY - rect.top + currentScrollTop;
        
        // 최종 상단/하단 좌표 계산
        const selectTop = Math.min(startY_abs, currentY_abs);
        const selectBottom = Math.max(startY_abs, currentY_abs);
        
        // 자동 스크롤 처리 - requestAnimationFrame 사용
        if (e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom) {
            
            // 이미 자동 스크롤이 진행 중이 아니면 시작
            if (autoScrollAnimationId === null) {
                autoScroll(e.clientX, e.clientY);
            }
        } else {
            // 마우스가 컨테이너를 벗어나면 자동 스크롤 취소
            cancelAutoScroll();
        }
        
        // 모든 파일 항목들을 순회하면서 선택 영역과 겹치는지 확인
        const items = document.querySelectorAll('.file-item');
        
        items.forEach(item => {
            // 상위 폴더 항목은 건너뜀
            if (item.getAttribute('data-parent-dir') === 'true') {
                return;
            }
            
            // 항목의 위치와 크기 계산 (절대 위치)
            const itemRect = item.getBoundingClientRect();
            const itemLeft = itemRect.left - rect.left + fileList.scrollLeft;
            const itemTop = itemRect.top - rect.top + fileList.scrollTop; // 현재 스크롤 위치 고려
            const itemRight = itemLeft + itemRect.width;
            const itemBottom = itemTop + itemRect.height;
            
            // 겹침 여부 확인 (절대 위치 기준)
            const overlap = !(
                itemRight < selectLeft ||
                itemLeft > selectRight ||
                itemBottom < selectTop ||
                itemTop > selectBottom
            );
            
            // 선택 상태 업데이트
            if (overlap) {
                if (!item.classList.contains('selected')) {
                    item.classList.add('selected');
                    selectedItems.add(item.getAttribute('data-name'));
                }
            } else if (!e.ctrlKey) {
                if (item.classList.contains('selected')) {
                    item.classList.remove('selected');
                    selectedItems.delete(item.getAttribute('data-name'));
                }
            }
        });
        
        // 그리드 뷰 항목도 처리
        const gridItems = document.querySelectorAll('.file-item-grid');
        
        gridItems.forEach(item => {
            // 상위 폴더 항목은 건너뜀
            if (item.getAttribute('data-parent-dir') === 'true') {
                return;
            }
            
            // 항목의 위치와 크기 계산 (절대 위치)
            const itemRect = item.getBoundingClientRect();
            const itemLeft = itemRect.left - rect.left + fileList.scrollLeft;
            const itemTop = itemRect.top - rect.top + fileList.scrollTop; // 현재 스크롤 위치 고려
            const itemRight = itemLeft + itemRect.width;
            const itemBottom = itemTop + itemRect.height;
            
            // 겹침 여부 확인 (절대 위치 기준)
            const overlap = !(
                itemRight < selectLeft ||
                itemLeft > selectRight ||
                itemBottom < selectTop ||
                itemTop > selectBottom
            );
            
            // 선택 상태 업데이트
            if (overlap) {
                if (!item.classList.contains('selected')) {
                    item.classList.add('selected');
                    selectedItems.add(item.getAttribute('data-name'));
                }
            } else if (!e.ctrlKey) {
                if (item.classList.contains('selected')) {
                    item.classList.remove('selected');
                    selectedItems.delete(item.getAttribute('data-name'));
                }
            }
        });
        
        // 선택 버튼 상태 업데이트
        updateButtonStates();
    });
    
    // 마우스 업 이벤트
    document.addEventListener('mouseup', (e) => {
        // 시작 표시가 없거나 드래그 이벤트가 아니면 무시
        if (!window.dragSelectState.isSelecting) return;
        
        // 자동 스크롤 중지
        cancelAutoScroll();
        
        const selectionBox = document.getElementById('selectionBox');
        selectionBox.style.display = 'none';
        
        // 전역 상태 초기화
        window.dragSelectState.isSelecting = false;
        window.dragSelectState.dragStarted = false;
        window.dragSelectState.startedOnFileItem = false;
        window.dragSelectState.startedOnSelectedItem = false;
        
        // 버튼 상태 업데이트
        updateButtonStates();
    });
}

// 전역 마우스 업 이벤트 핸들러 추가 - 드래그 상태 정리를 위한 안전장치
function setupGlobalDragCleanup() {
    // 전역 드래그 상태 관리
    window.isDraggingActive = false;
    window._isCleaningDragState = false; // 정리 함수 중복 호출 방지
    
    // 파일 드래그 시작 함수
    window.startFileDrag = function(items) {
        // 이미 드래그 중이면 무시 (혹시 모를 중복 호출 방지)
        if (window.isDraggingActive) return;
        
        window.isDraggingActive = true;
        console.log(`드래그 시작: ${items.size}개 항목 드래그 중`);
    };
    
    // 드래그 상태 정리 함수
    window.clearDragState = function() {
        // 이미 정리 중이면 더 이상 진행하지 않음
        if (window._isCleaningDragState) return;
        
        // 정리 시작 플래그 설정
        window._isCleaningDragState = true;
        console.log('clearDragState: 정리 시작');
        
        // 드래그 상태 플래그 초기화 (파일 이동/업로드 관련)
        window.isDraggingActive = false;
        
        // --- 드래그 선택 내부 상태 변수 초기화 ---
        window.dragSelectState.isSelecting = false;
        window.dragSelectState.dragStarted = false;
        window.dragSelectState.startedOnFileItem = false;
        window.dragSelectState.startedOnSelectedItem = false;
        console.log('clearDragState: 드래그 선택 상태 변수 초기화 완료');
        
        // --- 추가된 코드: 드래그 *선택* 상태 관련 정리 ---
        const selectionBox = document.getElementById('selectionBox');
        if (selectionBox) {
            selectionBox.style.display = 'none';
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            // 관련 데이터 속성 초기화 (드래그 선택 시작점 정보 제거)
            delete selectionBox.dataset.startClientX;
            delete selectionBox.dataset.startClientY;
            delete selectionBox.dataset.initialScrollTop;
            delete selectionBox.dataset.initialScrollLeft; // 수평 스크롤 정보도 제거
            console.log('clearDragState: 드래그 선택 박스 상태 초기화');
        }
        
        // 자동 스크롤 취소 (함수가 존재하는 경우)
        if (typeof cancelAutoScroll === 'function') {
            cancelAutoScroll();
        }
        
        // --- 추가된 코드 끝 ---
        
        // 모든 dragging 클래스 제거 (파일 이동/업로드 관련)
        const draggingElements = document.querySelectorAll('.dragging');
        if (draggingElements.length > 0) {
            console.log(`clearDragState: ${draggingElements.length}개의 dragging 클래스 제거`);
            draggingElements.forEach(el => el.classList.remove('dragging'));
        }
        
        // 모든 drag-over 클래스 제거 (파일 이동/업로드 관련)
        const dragOverElements = document.querySelectorAll('.drag-over');
        if (dragOverElements.length > 0) {
            console.log(`clearDragState: ${dragOverElements.length}개의 drag-over 클래스 제거`);
            dragOverElements.forEach(el => el.classList.remove('drag-over'));
        }
        
        console.log('clearDragState: 정리 완료');
        
        // 정리 완료 후 플래그 해제 (약간의 시간차를 두어 확실히 마무리)
        setTimeout(() => {
            window._isCleaningDragState = false;
        }, 0); 
    };
    
    // mouseup 이벤트: 드래그 상태 정리의 주된 트리거
    document.addEventListener('mouseup', (e) => {
        // 드래그가 활성화된 상태에서 마우스 버튼이 놓이면 정리
        if (window.isDraggingActive) {
            console.log('mouseup 이벤트 감지: 드래그 상태 정리 시도');
            window.clearDragState();
        }
    }, true);
    
    // mouseleave 이벤트: 마우스가 문서를 벗어날 때 안전장치로 정리
    document.addEventListener('mouseleave', (e) => {
        // 문서 경계를 벗어나는 경우에만 처리
        if (e.target === document.documentElement && window.isDraggingActive) {
            console.log('mouseleave 이벤트 감지: 문서를 벗어남, 드래그 상태 정리 시도');
            window.clearDragState();
        }
    });
}

// 드래그 종료 처리
function handleDragEnd() {
    // 전역 드래그 상태 정리 함수 호출
    if (window.clearDragState) {
        console.log('handleDragEnd 호출: 전역 함수로 정리');
        window.clearDragState();
    } else {
        console.log('handleDragEnd 호출: 기본 정리 로직 수행');
        // 모든 dragging 클래스 제거 (선택자 범위 확장)
        document.querySelectorAll('.dragging').forEach(item => {
            item.classList.remove('dragging');
        });
        
        // 모든 drag-over 클래스 제거 (선택자 범위 확장)
        document.querySelectorAll('.drag-over').forEach(item => {
            item.classList.remove('drag-over');
        });
        
        isDragging = false;
    }
}

// 단축키 초기화
function initShortcuts() {
    // 이미 초기화되었는지 확인
    if (window.shortcutsInitialized) {
        console.log('단축키가 이미 초기화되어 있습니다. 중복 호출 방지.');
        return;
    }
    
    document.addEventListener('keydown', (e) => {
        // F2: 이름 변경
        if (e.key === 'F2' && selectedItems.size === 1) {
            e.preventDefault();
            showRenameDialog();
        }
        
        // Delete: 선택 항목 삭제
        if (e.key === 'Delete' && selectedItems.size > 0) {
            e.preventDefault();
            deleteSelectedItems();
        }
        
        // Ctrl+A: 모두 선택
        if (e.key === 'a' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            selectAllItems();
        }
        
        // Ctrl+X: 잘라내기
        if (e.key === 'x' && (e.ctrlKey || e.metaKey) && selectedItems.size > 0) {
            e.preventDefault();
            cutSelectedItems();
        }
        
        // Ctrl+V: 붙여넣기
        if (e.key === 'v' && (e.ctrlKey || e.metaKey) && clipboardItems.length > 0) {
            e.preventDefault();
            pasteItems();
        }
        
        // Escape: 선택 취소
        if (e.key === 'Escape') {
            e.preventDefault();
            clearSelection();
            contextMenu.style.display = 'none';
        }
    });
    
    // 초기화 완료 플래그 설정
    window.shortcutsInitialized = true;
    console.log('단축키 초기화 완료');
}

// 디스크 사용량 가져오기
function loadDiskUsage() {
    showLoading();
    
    fetch(`${API_BASE_URL}/api/disk-usage`)
        .then(response => {
            if (!response.ok) {
                throw new Error('디스크 사용량 정보를 가져오는 데 실패했습니다.');
            }
            return response.json();
        })
        .then(data => {
            diskUsage = data;
            updateStorageInfoDisplay();
            hideLoading();
        })
        .catch(error => {
            console.error('디스크 사용량 정보 로드 오류:', error);
            hideLoading();
        });
}

// 저장소 정보 표시 업데이트
function updateStorageInfoDisplay() {
    if (!diskUsage) return;
    
    const storageInfoText = document.getElementById('storageInfoText');
    
    // 사용 가능한 공간과 전체 공간 계산 (GB 단위로 변환)
    const usedGB = (diskUsage.used / (1024 * 1024 * 1024)).toFixed(2);
    const totalGB = (diskUsage.total / (1024 * 1024 * 1024)).toFixed(2);
    const percentUsed = ((diskUsage.used / diskUsage.total) * 100).toFixed(1);
    
    // 사용량에 따른 상태 클래스 결정
    let statusClass = '';
    if (percentUsed > 90) {
        statusClass = 'danger';
    } else if (percentUsed > 75) {
        statusClass = 'warning';
    }
    
    // HTML 구성
    storageInfoText.innerHTML = `
        <span>${formatFileSize(diskUsage.used)} / ${formatFileSize(diskUsage.total)} (${percentUsed}%)</span>
        <div class="storage-bar-container">
            <div class="storage-bar ${statusClass}" style="width: ${percentUsed}%"></div>
        </div>
    `;
    
    // 상태바에 디스크 사용량 표시 추가
    const statusbar = document.getElementById('statusbar');
    const diskUsageInfo = document.createElement('div');
    diskUsageInfo.className = 'disk-usage-info';
    
    // 이미 있는 디스크 사용량 요소 제거
    const existingDiskInfo = statusbar.querySelector('.disk-usage-info');
    if (existingDiskInfo) {
        statusbar.removeChild(existingDiskInfo);
    }
    
    diskUsageInfo.innerHTML = `
        <div class="disk-usage-text">사용량: ${formatFileSize(diskUsage.used)} / ${formatFileSize(diskUsage.total)} (${percentUsed}%)</div>
        <div class="disk-usage-bar">
            <div class="disk-usage-fill" style="width: ${percentUsed}%"></div>
        </div>
    `;
    
    // 색상 설정
    const fill = diskUsageInfo.querySelector('.disk-usage-fill');
    if (percentUsed > 90) {
        fill.style.backgroundColor = '#dc3545'; // 빨간색
    } else if (percentUsed > 75) {
        fill.style.backgroundColor = '#ffc107'; // 노란색
    }
    
    statusbar.appendChild(diskUsageInfo);
}

// 파일 목록 로드 함수
function loadFiles(path = '') {
    showLoading();
    currentPath = path;
    
    // URL 인코딩 처리
    const encodedPath = path ? encodeURIComponent(path) : '';
    
    // 더블클릭이 가능한지 여부를 나타내는 전역 플래그
    window.doubleClickEnabled = false;
    
    fetch(`${API_BASE_URL}/api/files/${encodedPath}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`상태 ${response.status}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(data => {
            // 파일 정보 맵 업데이트
            fileInfoMap.clear();
            data.forEach(file => {
                fileInfoMap.set(file.name, {
                    type: file.isFolder ? 'folder' : 'file',
                    size: file.size,
                    modified: file.modifiedTime
                });
            });
            
            // 정렬 적용
            renderFiles(data);
            updateBreadcrumb(path);
            hideLoading();
            
            // 파일 드래그 이벤트 초기화
            initDragAndDrop();
            
            // 상태 업데이트
            statusInfo.textContent = `${data.length}개 항목`;
            
            // 로딩 완료 후 더블클릭 이벤트 활성화 (타이머 시간 증가)
            setTimeout(() => {
                window.doubleClickEnabled = true;
                console.log('더블클릭 이벤트 활성화됨');
            }, 300);
        })
        .catch(error => {
            console.error('Error:', error);
            statusInfo.textContent = `오류: ${error.message}`;
            hideLoading();
            
            // 오류 발생해도 더블클릭 이벤트 활성화
            window.doubleClickEnabled = true;
        });
    
    // 디스크 사용량 로드
    loadDiskUsage();
}

// 파일 정렬 함수
function sortFiles(files) {
    // 먼저 폴더와 파일 분리
    const folders = files.filter(file => file.isFolder);
    const nonFolders = files.filter(file => !file.isFolder);
    
    // 각각 정렬
    folders.sort((a, b) => {
        return compareValues(a, b, sortField, sortDirection);
    });
    
    nonFolders.sort((a, b) => {
        return compareValues(a, b, sortField, sortDirection);
    });
    
    // 폴더가 항상 먼저 오도록 합친다
    return [...folders, ...nonFolders];
}

// 값 비교 함수
function compareValues(a, b, field, direction) {
    let comparison = 0;
    const multiplier = direction === 'desc' ? -1 : 1;
    
    switch(field) {
        case 'name':
            comparison = a.name.localeCompare(b.name, 'ko');
            break;
        case 'size':
            comparison = a.size - b.size;
            break;
        case 'date':
            comparison = new Date(a.modifiedTime) - new Date(b.modifiedTime);
            break;
        default:
            comparison = a.name.localeCompare(b.name, 'ko');
    }
    
    return comparison * multiplier;
}

// 파일 목록 렌더링
function renderFiles(files) {
    // 파일 목록 초기화
    fileView.innerHTML = '';
    
    // 잠금 상태 로드 후 파일 렌더링
    showLoading();
    loadLockStatus()
        .then(() => {
            // 목록 보기인 경우 헤더 추가
            if (listView) {
                // 헤더 추가
                const headerDiv = document.createElement('div');
                headerDiv.className = 'file-list-header';
                headerDiv.innerHTML = `
                    <div class="header-icon"></div>
                    <div class="header-name" data-sort="name">이름 <i class="fas ${sortField === 'name' ? (sortDirection === 'asc' ? 'fa-sort-up' : 'fa-sort-down') : 'fa-sort'}"></i></div>
                    <div class="header-size" data-sort="size">크기 <i class="fas ${sortField === 'size' ? (sortDirection === 'asc' ? 'fa-sort-up' : 'fa-sort-down') : 'fa-sort'}"></i></div>
                    <div class="header-date" data-sort="date">수정일 <i class="fas ${sortField === 'date' ? (sortDirection === 'asc' ? 'fa-sort-up' : 'fa-sort-down') : 'fa-sort'}"></i></div>
                `;
                
                // 헤더 클릭 이벤트 추가
                headerDiv.querySelectorAll('[data-sort]').forEach(headerItem => {
                    headerItem.addEventListener('click', () => {
                        const sortBy = headerItem.getAttribute('data-sort');
                        if (sortField === sortBy) {
                            sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortField = sortBy;
                            sortDirection = 'asc';
                        }
                        loadFiles(currentPath);
                    });
                });
                
                fileView.appendChild(headerDiv);
            }
            
            // 파일 컨테이너 추가
            const filesContainer = document.createElement('div');
            filesContainer.id = 'fileList';
            
            // 목록 스타일 설정 (그리드 또는 리스트)
            filesContainer.className = listView ? 'file-list' : 'file-grid';
            fileView.appendChild(filesContainer);
            
            // 정렬된 파일 목록
            const sortedFiles = sortFiles(files);
            
            // 숨김 파일 필터링 (추가된 부분)
            // 이름이 .으로 시작하는 파일은 숨김 파일로 간주
            const visibleFiles = sortedFiles.filter(file => !file.name.startsWith('.'));
            
            // 잠금 상태 디버그 로깅
            console.log('현재 잠금 폴더 목록:', lockedFolders);
            
            // 상위 폴더로 이동 항목 추가 (루트 폴더가 아닌 경우)
            if (currentPath) {
                // 상위 디렉토리 항목 생성
                const parentItem = document.createElement('div');
                parentItem.className = 'file-item parent-dir';
                parentItem.setAttribute('data-id', '..');
                parentItem.setAttribute('data-name', '..');
                parentItem.setAttribute('data-is-folder', 'true');
                parentItem.setAttribute('data-parent-dir', 'true'); // 상위 폴더 표시를 위한 속성 추가
                
                // 아이콘 생성
                const parentIcon = document.createElement('div');
                parentIcon.className = 'file-icon';
                parentIcon.innerHTML = '<i class="fas fa-level-up-alt"></i>';
                
                // 이름 생성
                const parentName = document.createElement('div');
                parentName.className = 'file-name';
                parentName.innerText = '.. (상위 폴더)';
                
                // 빈 세부 정보
                const parentDetails = document.createElement('div');
                parentDetails.className = 'file-details';
                parentDetails.innerHTML = '<div class="file-size">--</div><div class="file-date">--</div>';
                
                // 부모 항목에 추가
                parentItem.appendChild(parentIcon);
                parentItem.appendChild(parentName);
                parentItem.appendChild(parentDetails);
                
                // 클릭 이벤트 추가 - 제거하고 더블클릭 이벤트로만 처리하도록 수정
                // 대신 initFileItem 함수를 통해 다른 파일/폴더와 동일하게 이벤트 처리
                
                // 컨테이너에 추가
                filesContainer.appendChild(parentItem);
                
                // initFileItem 함수 호출
                initFileItem(parentItem);
            }
            
            // 파일 목록 렌더링
            if (visibleFiles.length === 0 && !currentPath) {
                const noFilesDiv = document.createElement('div');
                noFilesDiv.className = 'no-files';
                noFilesDiv.textContent = '파일이 없습니다.';
                filesContainer.appendChild(noFilesDiv);
            } else {
                visibleFiles.forEach(file => {
                    // 파일 항목 생성
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.setAttribute('data-name', file.name);
                    fileItem.setAttribute('data-id', file.name); // ID 속성 추가
                    fileItem.setAttribute('data-is-folder', file.isFolder.toString());
                    fileItem.setAttribute('data-size', file.size);
                    fileItem.setAttribute('data-date', file.modifiedTime);
                    fileItem.setAttribute('draggable', 'true');
                    
                    // 상위 폴더인 경우 (..) 추가 속성 설정
                    if (file.name === '..') {
                        fileItem.setAttribute('data-parent-dir', 'true');
                    }
                    
                    // 파일 경로 계산
                    const filePath = currentPath ? `${currentPath}/${file.name}` : file.name;
                    fileItem.setAttribute('data-path', filePath);
                    
                    // 잠금 상태 확인 및 표시 - 직접 잠긴 폴더만 표시
                    const isDirectlyLocked = isPathLocked(filePath);
                    // 접근 제한 (상위 폴더가 잠겨있는 경우) 확인
                    const isRestricted = isPathAccessRestricted(filePath) && !isDirectlyLocked;
                    
                    if (file.isFolder && isDirectlyLocked) {
                        fileItem.classList.add('locked-folder');
                    } else if (file.isFolder && isRestricted) {
                        // fileItem.classList.add('restricted-folder'); // 주석 처리
                    }
                    
                    // 아이콘 생성
                    const fileIcon = document.createElement('div');
                    fileIcon.className = 'file-icon';
                    
                    // 폴더/파일 아이콘 설정
                    if (file.isFolder) {
                        fileIcon.innerHTML = '<i class="fas fa-folder"></i>';
                    } else {
                        const iconClass = getFileIconClass(file.name);
                        fileIcon.innerHTML = `<i class="${iconClass}"></i>`;
                    }
                    
                    // 파일명 생성
                    const fileName = document.createElement('div');
                    fileName.className = 'file-name';
                    fileName.innerText = file.name;
                    
                    // 파일 정보 생성
                    const fileDetails = document.createElement('div');
                    fileDetails.className = 'file-details';
                    
                    // 파일 크기 생성
                    const fileSize = document.createElement('div');
                    fileSize.className = 'file-size';
                    fileSize.innerText = file.isFolder ? '--' : formatFileSize(file.size);
                    
                    // 수정일 생성
                    const fileDate = document.createElement('div');
                    fileDate.className = 'file-date';
                    fileDate.innerText = formatDate(file.modifiedTime);
                    
                    // 파일 정보 추가
                    fileDetails.appendChild(fileSize);
                    fileDetails.appendChild(fileDate);
                    
                    // 파일 항목에 요소 추가
                    fileItem.appendChild(fileIcon);
                    fileItem.appendChild(fileName);
                    fileItem.appendChild(fileDetails);
                    
                    // 잠긴 폴더에 잠금 아이콘 추가
                    if (file.isFolder && isDirectlyLocked) {
                        const lockIcon = document.createElement('div');
                        lockIcon.className = 'lock-icon';
                        lockIcon.innerHTML = '<i class="fas fa-lock"></i>';
                        fileItem.appendChild(lockIcon);
                    }
                    
                    // 접근 제한된 폴더에 표시 추가
                    if (file.isFolder && isRestricted) {
                        const restrictedIcon = document.createElement('div');
                        restrictedIcon.className = 'restricted-icon';
                        restrictedIcon.innerHTML = '<i class="fas fa-shield-alt"></i>';
                        fileItem.appendChild(restrictedIcon);
                    }
                    
                    // 이벤트 리스너 설정
                    fileItem.addEventListener('click', (e) => {
                        if (e.target.classList.contains('rename-input')) return;
                        
                        // 상위 폴더(..)는 선택되지 않도록 처리
                        if (fileItem.getAttribute('data-parent-dir') === 'true') {
                            // 원클릭으로 상위 폴더 이동을 하지 않도록 수정
                            // 대신 handleFileClick 함수로 처리하여 더블클릭 이벤트에서만 이동하도록 함
                            e.preventDefault();
                            e.stopPropagation();
                            return;
                        }
                        
                        // 기존 핸들링 계속
                        handleFileClick(e, fileItem);
                    });
                    
                    // 더블클릭 이벤트
                    fileItem.addEventListener('dblclick', (e) => {
                        if (e.target.classList.contains('rename-input')) return;
                        
                        // handleFileDblClick 함수를 사용하여 통합 처리
                        handleFileDblClick(e, fileItem);
                    });
                    
                    // 파일 항목을 목록에 추가
                    filesContainer.appendChild(fileItem);
                });
            }
            
            // 리스트뷰 설정
            if (listView) {
                fileView.classList.add('list-view');
            } else {
                fileView.classList.remove('list-view');
            }
        
            // 상태 정보 업데이트 - 숨김 파일 카운트 포함
            const hiddenCount = sortedFiles.length - visibleFiles.length;
            if (hiddenCount > 0) {
                statusInfo.textContent = `${visibleFiles.length}개 항목 (${hiddenCount}개 숨김 파일 제외)`;
            } else {
                statusInfo.textContent = `${visibleFiles.length}개 항목`;
            }
            
            hideLoading();
        })
        .catch(error => {
            console.error('잠금 상태 로드 오류:', error);
            hideLoading();
            // 오류가 발생해도 파일 목록은 표시
            statusInfo.textContent = '파일 목록 로드 완료 (잠금 상태 오류)';
        });
}



// 파일 크기 포맷

// 날짜 포맷

// 경로 표시 업데이트

// 파일 클릭 처리

// 파일 더블클릭 처리

// 폴더 탐색

// 파일 다운로드
function downloadFile(fileName) {
    const filePath = currentPath ? `${currentPath}/${fileName}` : fileName;
    // 경로에 한글이 포함된 경우를 위해 인코딩 처리
    const encodedPath = encodeURIComponent(filePath);
    const fileUrl = `${API_BASE_URL}/api/files/${encodedPath}`;
    
    // 다운로드 링크를 새 창에서 열기
    window.open(fileUrl, '_blank');
    
    statusInfo.textContent = `${fileName} 다운로드 중...`;
    setTimeout(() => {
        statusInfo.textContent = `${fileName} 다운로드 완료`;
    }, 1000);
}

// 모든 항목 선택
function selectAllItems() {
    clearSelection();
    
    // 상위 폴더(..)를 제외한 모든 항목 선택
    document.querySelectorAll('.file-item:not([data-parent-dir="true"])').forEach(item => {
        item.classList.add('selected');
        selectedItems.add(item.getAttribute('data-name'));
    });
    
    updateButtonStates();
}

// 이름 변경 다이얼로그 표시


// 선택 항목 잘라내기

// 항목 붙여넣기

// 드래그 시작 처리



// 드래그 앤 드롭 초기화
function initDragAndDrop() {
    // 파일 리스트에 이벤트 위임 사용 - 동적으로 생성된 파일 항목에도 이벤트 처리
    const fileList = document.getElementById('fileList');
    const fileView = document.getElementById('fileView');
    const dropZone = document.getElementById('dropZone');
    
    if (!fileList || !fileView || !dropZone) {
        console.error('드래그앤드롭 초기화 중 필수 DOM 요소를 찾을 수 없습니다.');
        return;
    }
    
    console.log('초기화 시 드래그 클래스 정리');
    // 페이지 로드 시 이전에 남아있는 드래그 관련 클래스 모두 제거
    document.querySelectorAll('.dragging, .drag-over').forEach(element => {
        element.classList.remove('dragging', 'drag-over');
    });
    
    // 중복 초기화 방지 (이벤트 리스너가 중복 등록되는 것을 방지)
    fileList.removeEventListener('dragstart', handleFileDragStart);
    fileList.removeEventListener('dragend', handleFileDragEnd);
    fileList.removeEventListener('dragenter', handleFileDragEnter);
    fileList.removeEventListener('dragover', handleFileDragOver);
    fileList.removeEventListener('dragleave', handleFileDragLeave);
    fileList.removeEventListener('drop', handleFileDrop);
    
    // 이벤트 핸들러 함수 정의
    function handleFileDragStart(e) {
        // 상위 폴더는 드래그 불가능
        if (e.target.classList.contains('parent-dir') || e.target.closest('.file-item[data-parent-dir="true"]')) {
            e.preventDefault();
            return;
        }
        
        console.log('드래그 시작 - 대상:', e.target.className);
        
        // 파일 항목 요소 찾기
        const fileItem = e.target.closest('.file-item');
        if (!fileItem) return;
        
        // 전역 드래그 상태 변수 설정 - 내부 드래그 플래그 설정
        window.draggingInProgress = true;
        window.draggingStartTime = Date.now();
        
        const fileName = fileItem.getAttribute('data-name');
        console.log('드래그 시작:', fileName);
        
        // 선택되지 않은 항목을 드래그하는 경우, 선택 초기화 후 해당 항목만 선택
    if (!fileItem.classList.contains('selected')) {
        clearSelection();
        selectItem(fileItem);
    }

        // 드래그 중인 항목 개수
        const dragCount = selectedItems.size;
        console.log(`드래그 시작: ${dragCount}개 항목 드래그 중`);
        
        try {
            // 1. JSON 형식으로 드래그 데이터 설정 (파일 경로 포함)
            const draggedItems = Array.from(selectedItems).map(name => {
                return currentPath ? `${currentPath}/${name}` : name;
            });
            
            const jsonData = {
                source: 'internal',
                host: window.location.host,
                timestamp: Date.now(),
                items: draggedItems
            };
            e.dataTransfer.setData('application/json', JSON.stringify(jsonData));
            
            // 2. 내부 드래그 마커 설정 (보안 강화)
            e.dataTransfer.setData('application/x-internal-drag', 'true');

            // 3. 일반 텍스트 데이터로도 저장 (호환성 유지)
            e.dataTransfer.setData('text/plain', draggedItems.join('\n'));
            
            // 4. 드래그 이미지 효과 설정
            if (dragCount > 1) {
                e.dataTransfer.setDragImage(fileItem, 15, 15);
                e.dataTransfer.effectAllowed = 'move';
            }

            console.log('[File Drag Start] 내부 드래그 마커 설정 완료 (json, x-internal-drag)');
            console.log('[File Drag Start] dataTransfer types set:', Array.from(e.dataTransfer.types));

            // 5. 드래그 중인 항목에 시각적 효과 적용
            setTimeout(() => {
                document.querySelectorAll('.file-item.selected').forEach(item => {
                    item.classList.add('dragging');
                });
            }, 0);

        } catch (error) {
            console.error('드래그 시작 중 오류:', error);
            // 기본 정보만이라도 설정
            e.dataTransfer.setData('text/plain', fileName);
        }
    }
    
    function handleFileDragEnd(e) {
        console.log('파일 리스트 dragend 이벤트 발생');
        
        // 보편적인 드래그 상태 정리 함수 호출
        handleDragEnd();
        
        // 드롭존 비활성화
        dropZone.classList.remove('active');
    }
    
// 모든 drag-over 클래스를 제거하는 함수
function clearAllDragOverClasses() {
    document.querySelectorAll('.file-item.drag-over').forEach(item => {
        item.classList.remove('drag-over');
    });
}

function handleFileDragEnter(e) {
    const fileItem = e.target.closest('.file-item');
    if (!fileItem) {
        // 파일 항목이 없으면 모든 강조 제거
        clearAllDragOverClasses();
        return;
    }
    
    // 상위 폴더인 경우 드래그 오버 스타일 적용하지 않음
    if (fileItem.getAttribute('data-parent-dir') === 'true') {
        clearAllDragOverClasses();
        return;
    }
    
    // 폴더인 경우에만 처리하고 시각적 표시
    if (fileItem.getAttribute('data-is-folder') === 'true') {
        // 선택된 폴더에 대한 드래그는 무시
        if (fileItem.classList.contains('selected')) {
            console.log('자기 자신이나 하위 폴더에 드래그 불가: ', fileItem.getAttribute('data-name'));
            clearAllDragOverClasses();
            return;
        }
        
        // 다른 폴더들의 강조 제거
        clearAllDragOverClasses();
        
        console.log('드래그 진입:', fileItem.getAttribute('data-name'));
        // 현재 폴더에만 드래그 오버 스타일 적용
        fileItem.classList.add('drag-over');
    } else {
        // 파일인 경우 모든 강조 제거
        clearAllDragOverClasses();
    }
}
    
function handleFileDragOver(e) {
    e.preventDefault(); // 드롭 허용
    e.stopPropagation(); // 이벤트 버블링 방지
    
    const fileItem = e.target.closest('.file-item');
    
    // 파일 항목이 없거나 드래그 타겟이 파일 리스트인 경우
    if (!fileItem || e.target === fileList || e.target === fileView) {
        clearAllDragOverClasses();
        return;
    }
    
    // 상위 폴더인 경우 드래그 오버 처리하지 않음
    if (fileItem.getAttribute('data-parent-dir') === 'true') {
        e.dataTransfer.dropEffect = 'none'; // 드롭 불가능 표시
        clearAllDragOverClasses();
        return;
    }
    
    // 폴더인 경우에만 처리
    if (fileItem.getAttribute('data-is-folder') === 'true') {
        // 선택된 폴더에 대한 드래그는 무시
        if (fileItem.classList.contains('selected')) {
            e.dataTransfer.dropEffect = 'none'; // 드롭 불가능 표시
            clearAllDragOverClasses();
            return;
        }
        
        // 드롭존 비활성화 - 폴더에 드래그할 때는 전체 드롭존이 아닌 폴더 자체에 표시
        if (dropZone) {
            dropZone.classList.remove('active');
        }
        
        // 다른 요소의 강조 모두 제거하고 현재 폴더만 강조
        clearAllDragOverClasses();
        fileItem.classList.add('drag-over');
        
        // 기본 드롭 효과 설정 (드롭 후 판단)
        const hasExternalFiles = e.dataTransfer.files && e.dataTransfer.files.length > 0;
        e.dataTransfer.dropEffect = hasExternalFiles ? 'copy' : 'move';
    } else {
        // 파일 항목인 경우 모든 강조 제거
        clearAllDragOverClasses();
        e.dataTransfer.dropEffect = 'none'; // 파일에는 드롭 불가
    }
}
    
function handleFileDragLeave(e) {
    // 이 함수는 필요 없음 - dragover 이벤트에서 모든 처리를 수행
    // 빈 함수로 남겨둠
}

// 이벤트 리스너 등록
fileList.addEventListener('dragenter', handleFileDragEnter);
fileList.addEventListener('dragover', handleFileDragOver);
fileList.addEventListener('dragleave', handleFileDragLeave);
fileList.addEventListener('drop', handleFileDrop);

// 전체 영역 드롭존 이벤트 함수들
function handleDropZoneDragEnter(e) {
    e.preventDefault();
    e.stopPropagation();
    
        // 모든 드래그 이벤트에 대해 드롭존 활성화
        // 드롭 시점에 내부/외부 판단
        if (e.dataTransfer.types.includes('Files') || e.dataTransfer.types.includes('text/plain')) {
            dropZone.classList.add('active');
        }
    }
    
function handleDropZoneDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // 모든 드래그 이벤트에 대해 드롭존 유지
        // 드롭 시점에 내부/외부 판단
        if (e.dataTransfer.types.includes('Files') || e.dataTransfer.types.includes('text/plain')) {
            // 기본 드롭 효과 설정 (드롭 후 판단)
            const hasExternalFiles = e.dataTransfer.files && e.dataTransfer.files.length > 0;
            e.dataTransfer.dropEffect = hasExternalFiles ? 'copy' : 'move';
            dropZone.classList.add('active');
        }
    }
    
function handleDropZoneDragLeave(e) {
        // relatedTarget이 null이거나 dropZone의 자식 요소가 아닌 경우에만 비활성화
    if (!dropZone.contains(e.relatedTarget)) {
        dropZone.classList.remove('active');
    }
}

function handleDropZoneDrop(e) {
    console.log('드롭존에 파일 드롭됨');
    preventDefaults(e);
    
    // 드래그 상태 초기화
    window.draggingInProgress = false;
    
    // 내부/외부 파일 판단
    const { isExternalDrop, isInternalDrop, draggedPaths, reason } = determineDropType(e);
    
    // 최종 판단: 외부 파일이 있으면 외부 드롭으로 처리
    if (isExternalDrop) {
        console.log('드롭존 드롭 - 외부 파일 드롭 처리');
        handleExternalFileDrop(e, currentPath);
    } 
    // 내부 파일이라도 경로가 비어있으면 오류 처리
    else if (isInternalDrop && draggedPaths.length > 0) {
        console.log('드롭존 드롭 - 내부 파일 이동 처리:', draggedPaths);
        // 현재 드롭존의 경로로 파일 이동
        handleInternalFileDrop(draggedPaths, { path: currentPath });
    }
    // 판단 불가능한 경우
    else {
        console.log('드롭존 드롭 - 처리할 수 없는 드롭 데이터');
        showToast('처리할 수 없는 드롭 데이터입니다.', 'error');
        }
    }
    
    // 전체 영역 드롭존 이벤트 리스너 등록
    window.removeEventListener('dragenter', handleDropZoneDragEnter);
    window.removeEventListener('dragover', handleDropZoneDragOver);
    window.removeEventListener('dragleave', handleDropZoneDragLeave);
    dropZone.removeEventListener('drop', handleDropZoneDrop);
    
    console.log('드롭존 이벤트 리스너 등록 완료 (handleDrop 이벤트는 initDropZone에서 등록)');
    
    // 개발 모드에서 폴더 항목 CSS 선택자 유효성 확인
    console.log('폴더 항목 개수:', document.querySelectorAll('.file-item[data-is-folder="true"]').length);
}

// 내부 드래그인지 확인하는 함수 (파일 경로 기반 + 기본값은 내부)

// 내부 파일 드롭 처리 함수 (실제 이동 로직 구현)
async function handleInternalFileDrop(draggedItemPaths, targetFolderItem) {
    console.log('[Internal Drop] 내부 파일 이동 처리 시작:', draggedItemPaths);

    // 타겟 폴더 경로 결정
    let targetPath = currentPath;
    let targetName = '현재 폴더';
    
    // targetFolderItem이 유효한 폴더 요소인지 확인 (null 아니고, getAttribute 함수 가지고 있는지)
    if (targetFolderItem && typeof targetFolderItem.getAttribute === 'function') {
        // 타겟 폴더가 주어진 경우 (파일 항목에 드롭된 경우)
        const folderName = targetFolderItem.getAttribute('data-name');
        if (folderName) { // 폴더 이름이 있는지 한번 더 확인
             targetPath = currentPath ? `${currentPath}/${folderName}` : folderName;
             targetName = folderName;
        } else {
             console.warn('[Internal Drop] 타겟 요소에서 폴더 이름을 가져올 수 없습니다.', targetFolderItem);
             // 폴더 이름을 가져올 수 없으면 기본 경로 사용
        }
    } else if (targetFolderItem) {
         // targetFolderItem이 존재하지만 getAttribute 함수가 없는 경우 (예: 파일 목록 컨테이너)
         console.log('[Internal Drop] 드롭 대상이 폴더가 아닙니다. 현재 폴더를 타겟으로 합니다.');
         // 이 경우 targetPath와 targetName은 기본값(currentPath, '현재 폴더')을 유지
    }

    console.log(`[Internal Drop] 타겟 경로: ${targetPath}, 타겟 이름: ${targetName}`);
    
    // 드래그된 데이터가 유효한지 확인
    if (!Array.isArray(draggedItemPaths) || draggedItemPaths.length === 0) {
        console.error('[Internal Drop] 유효하지 않은 파일 경로 정보');
        showToast('이동할 항목 정보가 유효하지 않습니다.', 'error');
             return;
        }

    // 경로 처리 및 유효성 검사
    const validItemPaths = draggedItemPaths.filter(path => {
        // 경로가 유효한 문자열인지 확인
        if (typeof path !== 'string' || !path.trim()) {
            console.warn('[Internal Drop] 유효하지 않은 경로 제외:', path);
            return false;
        }
        return true;
    });
    
    if (validItemPaths.length === 0) {
        console.error('[Internal Drop] 유효한 경로가 없음');
        showToast('이동할 유효한 항목이 없습니다.', 'error');
        return;
    }
    
    // 경로 처리 및 이름 추출
    const itemsInfo = validItemPaths.map(path => {
        // 경로에서 파일/폴더 이름 추출
        const itemName = path.includes('/') ? path.substring(path.lastIndexOf('/') + 1) : path;
        // 경로에서 부모 경로 추출 (루트는 빈 문자열)
        const parentPath = path.includes('/') ? path.substring(0, path.lastIndexOf('/')) : '';
        
        // fileInfoMap에서 정보 가져오기 (이름으로 조회)
        const itemInfo = fileInfoMap.get(itemName) || null;
        
        return {
            fullPath: path,
            name: itemName,
            parentPath,
            isFolder: itemInfo ? itemInfo.isFolder : false,
            info: itemInfo
        };
    });
    
    console.log('[Internal Drop] 항목 정보:', itemsInfo);
    
    // --- 유효성 검사 시작 ---
    
    // 1. 타겟 폴더가 이동하려는 항목 중 하나인 경우 방지
    if (targetFolderItem) {
        const targetInDraggedItems = itemsInfo.some(item => item.fullPath === targetPath);
        if (targetInDraggedItems) {
            console.warn(`[Internal Drop] 선택된 항목 중 하나인 '${targetName}'(으)로는 이동할 수 없습니다.`);
             showToast(`선택된 항목 중 하나인 '${targetName}'(으)로는 이동할 수 없습니다.`, 'warning');
             return;
        }
    }
    
    // 2. 폴더를 자신의 하위 폴더로 이동하려는 경우 방지
    for (const item of itemsInfo) {
        if (item.isFolder && targetPath.startsWith(item.fullPath + '/')) {
            console.warn(`[Internal Drop] 폴더 '${item.name}'를 자신의 하위 폴더 '${targetName}'(으)로 이동할 수 없습니다.`);
            showToast(`폴더 '${item.name}'를 자신의 하위 폴더 '${targetName}'(으)로 이동할 수 없습니다.`, 'warning');
            return;
        }
    }
    
    // 3. 이미 대상 폴더에 있는 항목 필터링
    const itemsToMove = itemsInfo.filter(item => item.parentPath !== targetPath);
    
    if (itemsToMove.length === 0) {
        console.log('[Internal Drop] 이동할 필요가 있는 항목이 없습니다.');
        showToast('모든 항목이 이미 대상 폴더에 있습니다.', 'info');
        clearSelection();
        return;
    }

    // --- 유효성 검사 끝 ---
    
    // 이동 시작
    console.log(`[Internal Drop] ${itemsToMove.length}개 항목 이동 준비 완료:`, 
                itemsToMove.map(item => item.name));
    
    showLoading();
    try {
        // 실제 항목 이동 (이동할 항목의 전체 경로 배열 전달)
        await moveToFolder(itemsToMove.map(item => item.fullPath), targetPath);
        
        console.log('[Internal Drop] 이동 작업 성공');
        showToast(`${itemsToMove.length}개 항목을 '${targetName}'(으)로 이동했습니다.`, 'success');
        
        // 파일 목록 새로고침 (moveToFolder에서 처리하므로 제거)
        // loadFiles(currentPath);
    } catch (error) {
        console.error('[Internal Drop] 이동 중 오류 발생:', error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        showToast(`항목 이동 중 오류: ${errorMessage}`, 'error');
        
        // 오류 발생 시에도 파일 목록 새로고침 (moveToFolder에서 처리하므로 제거)
        // loadFiles(currentPath);
    } finally {
        hideLoading();
        clearSelection(); // 이동 후 선택 해제
    }
}

// 외부 파일 드롭 처리 함수
async function handleExternalFileDrop(e, targetFolderItem = null) { // async 키워드 추가
    if (isHandlingDrop) {
        console.log('이미 드롭 처리 중입니다. 중복 호출 방지.');
        return; // 중복 실행 방지
    }
    isHandlingDrop = true; // 처리 시작 플래그 설정

    try {
        // 진행 중인 업로드가 있는지 확인
        if (progressContainer.style.display === 'block') {
            statusInfo.textContent = '이미 업로드가 진행 중입니다. 완료 후 다시 시도하세요.';
            console.log('이미 진행 중인 업로드가 있어 새 업로드를 취소합니다.');
            return;
        }

        // DataTransferItemList 사용
        const items = e.dataTransfer.items;
        if (!items || items.length === 0) {
            console.log('드롭된 항목이 없습니다.');
            return;
        }

        // 업로드 소스 설정 및 카운터 초기화
        uploadSource = 'dragdrop';
        dragDropCounter = 0;

        let targetPath = currentPath; // 기본 업로드 경로는 현재 경로

        // 타겟 폴더가 지정된 경우 경로 업데이트
        if (targetFolderItem) {
            const targetFolder = targetFolderItem.getAttribute('data-name');
            targetPath = currentPath ? `${currentPath}/${targetFolder}` : targetFolder;
            console.log('외부 파일 드래그 감지: 대상 폴더:', targetFolder);
                    } else {
            console.log('외부 파일 드래그 감지: 현재 경로에 업로드');
        }

        showLoading();
        statusInfo.textContent = '파일 목록을 읽는 중...';

        const filesWithPaths = [];
        const promises = [];

        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item.kind === 'file') {
                const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : null;
                if (entry) {
                    promises.push(traverseFileTree(entry, '', filesWithPaths));
                } else {
                    // webkitGetAsEntry가 지원되지 않는 경우 직접 파일 가져오기
                    const file = item.getAsFile();
                    if (file) {
                        filesWithPaths.push({ file, relativePath: file.name });
                    }
                }
            }
        }

        await Promise.all(promises);

        hideLoading();

        if (filesWithPaths.length === 0) {
            statusInfo.textContent = '업로드할 파일을 찾을 수 없습니다.';
            console.log('업로드할 파일이 없습니다.');
            return;
        }

        console.log(`총 ${filesWithPaths.length}개의 파일 수집 완료.`);
        // uploadFiles 함수 호출 시 targetPath 전달
        uploadFiles(filesWithPaths, targetPath); // 수정: targetPath 전달

    } catch (error) {
        hideLoading();
        statusInfo.textContent = '파일 목록 읽기 오류.';
        console.error('파일 트리 탐색 오류:', error);
        alert('파일 목록을 읽는 중 오류가 발생했습니다.');
    } finally {
        isHandlingDrop = false; // 처리 완료 또는 오류 발생 시 플래그 해제
    }
}

// 파일 트리 탐색 함수 (폴더 포함)


// 특정 폴더에 파일 업로드 (files 인자 변경: File[] -> { file: File, relativePath: string }[])
// targetUploadPath 인자 추가

// 파일/폴더 이동 함수

// 뷰 모드 전환

// 폴더 생성 기능 초기화

// 이름 변경 기능 초기화


// 파일 업로드 기능 초기화

// 잘라내기/붙여넣기 기능 초기화

// 삭제 기능 초기화

// 검색 기능 초기화

// 선택된 파일 다운로드

// 여러 파일/폴더를 압축하여 다운로드

// 항목 이동

// 상위 폴더로 이동

// 브라우저 히스토리 상태 업데이트

// 브라우저 뒤로가기/앞으로가기 이벤트 처리

// 파일 다운로드 및 실행 함수

// 애플리케이션 초기화
function init() {
    // 마우스 및 키보드 이벤트 핸들러 설정
    setupGlobalDragCleanup();
    
    console.log('WebDAV 파일 탐색기 초기화 시작');
    
    // 모달 초기화
    initModals();
    
    // 드래그 선택 초기화
    initDragSelect();
    
    // 컨텍스트 메뉴 초기화
    initContextMenu();
    
    // 뷰 모드 초기화
    initViewModes();
    
    // 새 폴더 생성 초기화
    initFolderCreation();
    
    // 이름 변경 초기화
    initRenaming();
    
    // 파일 업로드 초기화 (upload.js 기능 사용)
    // initFileUpload(); // 기존 코드 주석 처리
    
    // 대신 업로드 버튼에 클릭 이벤트 추가
    const uploadButton = document.querySelector('.upload-form .btn-success');
    if (uploadButton) {
        uploadButton.addEventListener('click', () => {
            const fileUploadInput = document.getElementById('fileUpload');
            if (fileUploadInput) {
                fileUploadInput.click(); // 파일 선택 창 열기
                console.log('[Script] 업로드 버튼 클릭 - 파일 선택 대화상자 열기');
            } else {
                console.error('[Script] 파일 업로드 입력 요소를 찾을 수 없습니다.');
            }
        });
    } else {
        console.error('[Script] 업로드 버튼을 찾을 수 없습니다.');
    }
    
    // upload.js의 초기화 함수 호출
    if (typeof window.initializeUploader === 'function') {
        console.log('[Script] upload.js 초기화 함수 호출');
        window.initializeUploader();
    } else {
        console.error('[Script] upload.js의 초기화 함수를 찾을 수 없습니다.');
    }
    
    // 잘라내기/붙여넣기 초기화
    initClipboardOperations();
    
    // 삭제 초기화
    initDeletion();
    
    // 검색 초기화
    initSearch();
    
    // 다운로드 버튼 이벤트 추가
    downloadBtn.addEventListener('click', downloadSelectedItems);
    
    // 새로고침 버튼 이벤트 추가
    document.getElementById('refreshStorageBtn').addEventListener('click', () => {
        loadDiskUsage();
    });
    
    // 초기 파일 목록 로드
    loadFiles(currentPath);
    
    // 드롭존 초기화
    initDropZone();
    
    // 스토리지 정보 로드
    loadDiskUsage();
    
    console.log('WebDAV 파일 탐색기 초기화됨');
}

// 페이지 로드 시 애플리케이션 초기화
document.addEventListener('DOMContentLoaded', init);

// 선택한 파일 압축






// 드래그 선택 상태 관련 전역 변수 추가
window.dragSelectState = {
    isSelecting: false,
    dragStarted: false,
    startedOnFileItem: false,
    startedOnSelectedItem: false
};











// 폴더 탐색

// 이름 변경 다이얼로그 표시


// 선택 항목 잘라내기
function cutSelectedItems() {
    if (selectedItems.size === 0) return;
    
    // 이전에 잘라내기 표시된 항목 초기화
    document.querySelectorAll('.file-item.cut').forEach(item => {
        item.classList.remove('cut');
    });
    
    clipboardItems = [];
    
    // 상위 폴더(..)는 제외
    const itemsToProcess = new Set([...selectedItems].filter(itemId => itemId !== '..'));
    
    if (itemsToProcess.size === 0) {
        alert('잘라낼 항목이 없습니다. 상위 폴더는 잘라낼 수 없습니다.');
        return;
    }
    
    // 현재 선택된 항목을 클립보드에 복사
    itemsToProcess.forEach(itemId => {
        const element = document.querySelector(`.file-item[data-id="${itemId}"]`);
        clipboardItems.push({
            name: itemId,
            isFolder: element.getAttribute('data-is-folder') === 'true',
            originalPath: currentPath
        });
        
        // 잘라내기 표시
        element.classList.add('cut');
    });
    
    clipboardOperation = 'cut';
    pasteBtn.disabled = false;
    
    document.getElementById('ctxPaste').style.display = 'flex';
    
    statusInfo.textContent = `${clipboardItems.length}개 항목 잘라내기`;
    
    // 디버그 로그
    console.log('잘라내기 항목:', clipboardItems);
}

// 드래그 시작 처리
    


// 내부 드래그인지 확인하는 함수 (파일 경로 기반 + 기본값은 내부)

// 내부 파일 드롭 처리 함수 (실제 이동 로직 구현)
async function handleInternalFileDrop(draggedItemPaths, targetFolderItem) {
    console.log('[Internal Drop] 내부 파일 이동 처리 시작:', draggedItemPaths);

    // 타겟 폴더 경로 결정
    let targetPath = currentPath;
    let targetName = '현재 폴더';
    
    // targetFolderItem이 유효한 폴더 요소인지 확인 (null 아니고, getAttribute 함수 가지고 있는지)
    if (targetFolderItem && typeof targetFolderItem.getAttribute === 'function') {
        // 타겟 폴더가 주어진 경우 (파일 항목에 드롭된 경우)
        const folderName = targetFolderItem.getAttribute('data-name');
        if (folderName) { // 폴더 이름이 있는지 한번 더 확인
             targetPath = currentPath ? `${currentPath}/${folderName}` : folderName;
             targetName = folderName;
        } else {
             console.warn('[Internal Drop] 타겟 요소에서 폴더 이름을 가져올 수 없습니다.', targetFolderItem);
             // 폴더 이름을 가져올 수 없으면 기본 경로 사용
        }
    } else if (targetFolderItem) {
         // targetFolderItem이 존재하지만 getAttribute 함수가 없는 경우 (예: 파일 목록 컨테이너)
         console.log('[Internal Drop] 드롭 대상이 폴더가 아닙니다. 현재 폴더를 타겟으로 합니다.');
         // 이 경우 targetPath와 targetName은 기본값(currentPath, '현재 폴더')을 유지
    }

    console.log(`[Internal Drop] 타겟 경로: ${targetPath}, 타겟 이름: ${targetName}`);
    
    // 드래그된 데이터가 유효한지 확인
    if (!Array.isArray(draggedItemPaths) || draggedItemPaths.length === 0) {
        console.error('[Internal Drop] 유효하지 않은 파일 경로 정보');
        showToast('이동할 항목 정보가 유효하지 않습니다.', 'error');
             return;
        }

    // 경로 처리 및 유효성 검사
    const validItemPaths = draggedItemPaths.filter(path => {
        // 경로가 유효한 문자열인지 확인
        if (typeof path !== 'string' || !path.trim()) {
            console.warn('[Internal Drop] 유효하지 않은 경로 제외:', path);
            return false;
        }
        return true;
    });
    
    if (validItemPaths.length === 0) {
        console.error('[Internal Drop] 유효한 경로가 없음');
        showToast('이동할 유효한 항목이 없습니다.', 'error');
        return;
    }
    
    // 경로 처리 및 이름 추출
    const itemsInfo = validItemPaths.map(path => {
        // 경로에서 파일/폴더 이름 추출
        const itemName = path.includes('/') ? path.substring(path.lastIndexOf('/') + 1) : path;
        // 경로에서 부모 경로 추출 (루트는 빈 문자열)
        const parentPath = path.includes('/') ? path.substring(0, path.lastIndexOf('/')) : '';
        
        // fileInfoMap에서 정보 가져오기 (이름으로 조회)
        const itemInfo = fileInfoMap.get(itemName) || null;
        
        return {
            fullPath: path,
            name: itemName,
            parentPath,
            isFolder: itemInfo ? itemInfo.isFolder : false,
            info: itemInfo
        };
    });
    
    console.log('[Internal Drop] 항목 정보:', itemsInfo);
    
    // --- 유효성 검사 시작 ---
    
    // 1. 타겟 폴더가 이동하려는 항목 중 하나인 경우 방지
    if (targetFolderItem) {
        const targetInDraggedItems = itemsInfo.some(item => item.fullPath === targetPath);
        if (targetInDraggedItems) {
            console.warn(`[Internal Drop] 선택된 항목 중 하나인 '${targetName}'(으)로는 이동할 수 없습니다.`);
             showToast(`선택된 항목 중 하나인 '${targetName}'(으)로는 이동할 수 없습니다.`, 'warning');
             return;
        }
    }
    
    // 2. 폴더를 자신의 하위 폴더로 이동하려는 경우 방지
    for (const item of itemsInfo) {
        if (item.isFolder && targetPath.startsWith(item.fullPath + '/')) {
            console.warn(`[Internal Drop] 폴더 '${item.name}'를 자신의 하위 폴더 '${targetName}'(으)로 이동할 수 없습니다.`);
            showToast(`폴더 '${item.name}'를 자신의 하위 폴더 '${targetName}'(으)로 이동할 수 없습니다.`, 'warning');
            return;
        }
    }
    
    // 3. 이미 대상 폴더에 있는 항목 필터링
    const itemsToMove = itemsInfo.filter(item => item.parentPath !== targetPath);
    
    if (itemsToMove.length === 0) {
        console.log('[Internal Drop] 이동할 필요가 있는 항목이 없습니다.');
        showToast('모든 항목이 이미 대상 폴더에 있습니다.', 'info');
        clearSelection();
        return;
    }

    // --- 유효성 검사 끝 ---
    
    // 이동 시작
    console.log(`[Internal Drop] ${itemsToMove.length}개 항목 이동 준비 완료:`, 
                itemsToMove.map(item => item.name));
    
    showLoading();
    try {
        // 실제 항목 이동 (이동할 항목의 전체 경로 배열 전달)
        await moveToFolder(itemsToMove.map(item => item.fullPath), targetPath);
        
        // console.log('[Internal Drop] 이동 작업 성공');
        // showToast(`${itemsToMove.length}개 항목을 '${targetName}'(으)로 이동했습니다.`, 'success');
        
        // 파일 목록 새로고침 (moveToFolder에서 처리하므로 제거)
        // loadFiles(currentPath);
    } catch (error) {
        console.error('[Internal Drop] 이동 중 오류 발생:', error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        showToast(`항목 이동 중 오류: ${errorMessage}`, 'error');
        
        // 오류 발생 시에도 파일 목록 새로고침 (moveToFolder에서 처리하므로 제거)
        // loadFiles(currentPath);
    } finally {
        hideLoading();
        clearSelection(); // 이동 후 선택 해제
    }
}

// 외부 파일 드롭 처리 함수
async function handleExternalFileDrop(e, targetFolderItem = null) { // async 키워드 추가
    if (isHandlingDrop) {
        console.log('이미 드롭 처리 중입니다. 중복 호출 방지.');
        return; // 중복 실행 방지
    }
    isHandlingDrop = true; // 처리 시작 플래그 설정

    try {
        // 진행 중인 업로드가 있는지 확인
        if (progressContainer.style.display === 'block') {
            statusInfo.textContent = '이미 업로드가 진행 중입니다. 완료 후 다시 시도하세요.';
            console.log('이미 진행 중인 업로드가 있어 새 업로드를 취소합니다.');
            return;
        }

        // DataTransferItemList 사용
        const items = e.dataTransfer.items;
        if (!items || items.length === 0) {
            console.log('드롭된 항목이 없습니다.');
            return;
        }

        // 업로드 소스 설정 및 카운터 초기화
        uploadSource = 'dragdrop';
        dragDropCounter = 0;

        let targetPath = currentPath; // 기본 업로드 경로는 현재 경로

        // 타겟 폴더가 지정된 경우 경로 업데이트
        if (targetFolderItem) {
            const targetFolder = targetFolderItem.getAttribute('data-name');
            targetPath = currentPath ? `${currentPath}/${targetFolder}` : targetFolder;
            console.log('외부 파일 드래그 감지: 대상 폴더:', targetFolder);
                    } else {
            console.log('외부 파일 드래그 감지: 현재 경로에 업로드');
        }

        showLoading();
        statusInfo.textContent = '파일 목록을 읽는 중...';

        const filesWithPaths = [];
        const promises = [];

        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item.kind === 'file') {
                const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : null;
                if (entry) {
                    promises.push(traverseFileTree(entry, '', filesWithPaths));
                } else {
                    // webkitGetAsEntry가 지원되지 않는 경우 직접 파일 가져오기
                    const file = item.getAsFile();
                    if (file) {
                        filesWithPaths.push({ file, relativePath: file.name });
                    }
                }
            }
        }

        await Promise.all(promises);

        hideLoading();

        if (filesWithPaths.length === 0) {
            statusInfo.textContent = '업로드할 파일을 찾을 수 없습니다.';
            console.log('업로드할 파일이 없습니다.');
            return;
        }

        console.log(`총 ${filesWithPaths.length}개의 파일 수집 완료.`);
        // uploadFiles 함수 호출 시 targetPath 전달
        uploadFiles(filesWithPaths, targetPath); // 수정: targetPath 전달

    } catch (error) {
        hideLoading();
        statusInfo.textContent = '파일 목록 읽기 오류.';
        console.error('파일 트리 탐색 오류:', error);
        alert('파일 목록을 읽는 중 오류가 발생했습니다.');
    } finally {
        isHandlingDrop = false; // 처리 완료 또는 오류 발생 시 플래그 해제
    }
}

// 파일 트리 탐색 함수 (폴더 포함)


// 특정 폴더에 파일 업로드 (files 인자 변경: File[] -> { file: File, relativePath: string }[])
// targetUploadPath 인자 추가

// 파일/폴더 이동 함수

// 뷰 모드 전환

// 폴더 생성 기능 초기화

// 이름 변경 기능 초기화


// 파일 업로드 기능 초기화

// 잘라내기/붙여넣기 기능 초기화

// 삭제 기능 초기화

// 검색 기능 초기화

// 선택된 파일 다운로드

// 여러 파일/폴더를 압축하여 다운로드

// 항목 이동

// 상위 폴더로 이동

// 브라우저 히스토리 상태 업데이트

// 브라우저 뒤로가기/앞으로가기 이벤트 처리

// 파일 다운로드 및 실행 함수

// 애플리케이션 초기화
function init() {
    // 마우스 및 키보드 이벤트 핸들러 설정
    setupGlobalDragCleanup();
    
    console.log('WebDAV 파일 탐색기 초기화 시작');
    
    // 모달 초기화
    initModals();
    
    // 드래그 선택 초기화
    initDragSelect();
    
    // 컨텍스트 메뉴 초기화
    initContextMenu();
    
    // 뷰 모드 초기화
    initViewModes();
    
    // 새 폴더 생성 초기화
    initFolderCreation();
    
    // 이름 변경 초기화
    initRenaming();
    
    // 파일 업로드 초기화 (upload.js 기능 사용)
    // initFileUpload(); // 기존 코드 주석 처리
    
    // 대신 업로드 버튼에 클릭 이벤트 추가
    const uploadButton = document.querySelector('.upload-form .btn-success');
    if (uploadButton) {
        uploadButton.addEventListener('click', () => {
            const fileUploadInput = document.getElementById('fileUpload');
            if (fileUploadInput) {
                fileUploadInput.click(); // 파일 선택 창 열기
                console.log('[Script] 업로드 버튼 클릭 - 파일 선택 대화상자 열기');
            } else {
                console.error('[Script] 파일 업로드 입력 요소를 찾을 수 없습니다.');
            }
        });
    } else {
        console.error('[Script] 업로드 버튼을 찾을 수 없습니다.');
    }
    
    // upload.js의 초기화 함수 호출
    if (typeof window.initializeUploader === 'function') {
        console.log('[Script] upload.js 초기화 함수 호출');
        window.initializeUploader();
    } else {
        console.error('[Script] upload.js의 초기화 함수를 찾을 수 없습니다.');
    }
    
    // 잘라내기/붙여넣기 초기화
    initClipboardOperations();
    
    // 삭제 초기화
    initDeletion();
    
    // 검색 초기화
    initSearch();
    
    // 다운로드 버튼 이벤트 추가
    downloadBtn.addEventListener('click', downloadSelectedItems);
    
    // 새로고침 버튼 이벤트 추가
    document.getElementById('refreshStorageBtn').addEventListener('click', () => {
        loadDiskUsage();
    });
    
    // 초기 파일 목록 로드
    loadFiles(currentPath);
    
    // 드롭존 초기화
    initDropZone();
    
    // 스토리지 정보 로드
    loadDiskUsage();
    
    console.log('WebDAV 파일 탐색기 초기화됨');
}

// 페이지 로드 시 애플리케이션 초기화
document.addEventListener('DOMContentLoaded', init);

// 선택한 파일 압축






// 드래그 선택 상태 관련 전역 변수 추가
window.dragSelectState = {
    isSelecting: false,
    dragStarted: false,
    startedOnFileItem: false,
    startedOnSelectedItem: false
};











// 폴더 탐색

// 이름 변경 다이얼로그 표시


// 선택 항목 잘라내기
function cutSelectedItems() {
    if (selectedItems.size === 0) return;
    
    // 이전에 잘라내기 표시된 항목 초기화
    document.querySelectorAll('.file-item.cut').forEach(item => {
        item.classList.remove('cut');
    });
    
    clipboardItems = [];
    
    // 상위 폴더(..)는 제외
    const itemsToProcess = new Set([...selectedItems].filter(itemId => itemId !== '..'));
    
    if (itemsToProcess.size === 0) {
        alert('잘라낼 항목이 없습니다. 상위 폴더는 잘라낼 수 없습니다.');
        return;
    }
    
    // 현재 선택된 항목을 클립보드에 복사
    itemsToProcess.forEach(itemId => {
        const element = document.querySelector(`.file-item[data-id="${itemId}"]`);
        clipboardItems.push({
            name: itemId,
            isFolder: element.getAttribute('data-is-folder') === 'true',
            originalPath: currentPath
        });
        
        // 잘라내기 표시
        element.classList.add('cut');
    });
    
    clipboardOperation = 'cut';
    pasteBtn.disabled = false;
    
    document.getElementById('ctxPaste').style.display = 'flex';
    
    statusInfo.textContent = `${clipboardItems.length}개 항목 잘라내기`;
    
    // 디버그 로그
    console.log('잘라내기 항목:', clipboardItems);
}

// 드래그 시작 처리
    


// 내부 드래그인지 확인하는 함수 (파일 경로 기반 + 기본값은 내부)

// 내부 파일 드롭 처리 함수 (실제 이동 로직 구현)
async function handleInternalFileDrop(draggedItemPaths, targetFolderItem) {
    console.log('[Internal Drop] 내부 파일 이동 처리 시작:', draggedItemPaths);

    // 타겟 폴더 경로 결정
    let targetPath = currentPath;
    let targetName = '현재 폴더';
    
    // targetFolderItem이 유효한 폴더 요소인지 확인 (null 아니고, getAttribute 함수 가지고 있는지)
    if (targetFolderItem && typeof targetFolderItem.getAttribute === 'function') {
        // 타겟 폴더가 주어진 경우 (파일 항목에 드롭된 경우)
        const folderName = targetFolderItem.getAttribute('data-name');
        if (folderName) { // 폴더 이름이 있는지 한번 더 확인
             targetPath = currentPath ? `${currentPath}/${folderName}` : folderName;
             targetName = folderName;
        } else {
             console.warn('[Internal Drop] 타겟 요소에서 폴더 이름을 가져올 수 없습니다.', targetFolderItem);
             // 폴더 이름을 가져올 수 없으면 기본 경로 사용
        }
    } else if (targetFolderItem) {
         // targetFolderItem이 존재하지만 getAttribute 함수가 없는 경우 (예: 파일 목록 컨테이너)
         console.log('[Internal Drop] 드롭 대상이 폴더가 아닙니다. 현재 폴더를 타겟으로 합니다.');
         // 이 경우 targetPath와 targetName은 기본값(currentPath, '현재 폴더')을 유지
    }

    console.log(`[Internal Drop] 타겟 경로: ${targetPath}, 타겟 이름: ${targetName}`);
    
    // 드래그된 데이터가 유효한지 확인
    if (!Array.isArray(draggedItemPaths) || draggedItemPaths.length === 0) {
        console.error('[Internal Drop] 유효하지 않은 파일 경로 정보');
        showToast('이동할 항목 정보가 유효하지 않습니다.', 'error');
             return;
        }

    // 경로 처리 및 유효성 검사
    const validItemPaths = draggedItemPaths.filter(path => {
        // 경로가 유효한 문자열인지 확인
        if (typeof path !== 'string' || !path.trim()) {
            console.warn('[Internal Drop] 유효하지 않은 경로 제외:', path);
            return false;
        }
        return true;
    });
    
    if (validItemPaths.length === 0) {
        console.error('[Internal Drop] 유효한 경로가 없음');
        showToast('이동할 유효한 항목이 없습니다.', 'error');
        return;
    }
    
    // 경로 처리 및 이름 추출
    const itemsInfo = validItemPaths.map(path => {
        // 경로에서 파일/폴더 이름 추출
        const itemName = path.includes('/') ? path.substring(path.lastIndexOf('/') + 1) : path;
        // 경로에서 부모 경로 추출 (루트는 빈 문자열)
        const parentPath = path.includes('/') ? path.substring(0, path.lastIndexOf('/')) : '';
        
        // fileInfoMap에서 정보 가져오기 (이름으로 조회)
        const itemInfo = fileInfoMap.get(itemName) || null;
        
        return {
            fullPath: path,
            name: itemName,
            parentPath,
            isFolder: itemInfo ? itemInfo.isFolder : false,
            info: itemInfo
        };
    });
    
    console.log('[Internal Drop] 항목 정보:', itemsInfo);
    
    // --- 유효성 검사 시작 ---
    
    // 1. 타겟 폴더가 이동하려는 항목 중 하나인 경우 방지
    if (targetFolderItem) {
        const targetInDraggedItems = itemsInfo.some(item => item.fullPath === targetPath);
        if (targetInDraggedItems) {
            console.warn(`[Internal Drop] 선택된 항목 중 하나인 '${targetName}'(으)로는 이동할 수 없습니다.`);
             showToast(`선택된 항목 중 하나인 '${targetName}'(으)로는 이동할 수 없습니다.`, 'warning');
             return;
        }
    }
    
    // 2. 폴더를 자신의 하위 폴더로 이동하려는 경우 방지
    for (const item of itemsInfo) {
        if (item.isFolder && targetPath.startsWith(item.fullPath + '/')) {
            console.warn(`[Internal Drop] 폴더 '${item.name}'를 자신의 하위 폴더 '${targetName}'(으)로 이동할 수 없습니다.`);
            showToast(`폴더 '${item.name}'를 자신의 하위 폴더 '${targetName}'(으)로 이동할 수 없습니다.`, 'warning');
            return;
        }
    }
    
    // 3. 이미 대상 폴더에 있는 항목 필터링
    const itemsToMove = itemsInfo.filter(item => item.parentPath !== targetPath);
    
    if (itemsToMove.length === 0) {
        console.log('[Internal Drop] 이동할 필요가 있는 항목이 없습니다.');
        showToast('모든 항목이 이미 대상 폴더에 있습니다.', 'info');
        clearSelection();
        return;
    }

    // --- 유효성 검사 끝 ---
    
    // 이동 시작
    console.log(`[Internal Drop] ${itemsToMove.length}개 항목 이동 준비 완료:`, 
                itemsToMove.map(item => item.name));
    
    showLoading();
    try {
        // 실제 항목 이동 (이동할 항목의 전체 경로 배열 전달)
        await moveToFolder(itemsToMove.map(item => item.fullPath), targetPath);
        
        // console.log('[Internal Drop] 이동 작업 성공');
        // showToast(`${itemsToMove.length}개 항목을 '${targetName}'(으)로 이동했습니다.`, 'success');
        
        // 파일 목록 새로고침 (moveToFolder에서 처리하므로 제거)
        // loadFiles(currentPath);
    } catch (error) {
        console.error('[Internal Drop] 이동 중 오류 발생:', error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        showToast(`항목 이동 중 오류: ${errorMessage}`, 'error');
        
        // 오류 발생 시에도 파일 목록 새로고침 (moveToFolder에서 처리하므로 제거)
        // loadFiles(currentPath);
    } finally {
        hideLoading();
        clearSelection(); // 이동 후 선택 해제
    }
}

// 외부 파일 드롭 처리 함수
async function handleExternalFileDrop(e, targetFolderItem = null) { // async 키워드 추가
    if (isHandlingDrop) {
        console.log('이미 드롭 처리 중입니다. 중복 호출 방지.');
        return; // 중복 실행 방지
    }
    isHandlingDrop = true; // 처리 시작 플래그 설정

    try {
        // 진행 중인 업로드가 있는지 확인
        if (progressContainer.style.display === 'block') {
            statusInfo.textContent = '이미 업로드가 진행 중입니다. 완료 후 다시 시도하세요.';
            console.log('이미 진행 중인 업로드가 있어 새 업로드를 취소합니다.');
            return;
        }

        // DataTransferItemList 사용
        const items = e.dataTransfer.items;
        if (!items || items.length === 0) {
            console.log('드롭된 항목이 없습니다.');
            return;
        }

        // 업로드 소스 설정 및 카운터 초기화
        uploadSource = 'dragdrop';
        dragDropCounter = 0;

        let targetPath = currentPath; // 기본 업로드 경로는 현재 경로

        // 타겟 폴더가 지정된 경우 경로 업데이트
        if (targetFolderItem) {
            const targetFolder = targetFolderItem.getAttribute('data-name');
            targetPath = currentPath ? `${currentPath}/${targetFolder}` : targetFolder;
            console.log('외부 파일 드래그 감지: 대상 폴더:', targetFolder);
        } else {
            console.log('외부 파일 드래그 감지: 현재 경로에 업로드');
        }

        showLoading();
        statusInfo.textContent = '파일 목록을 읽는 중...';

        const filesWithPaths = [];
        const promises = [];

        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item.kind === 'file') {
                const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : null;
                if (entry) {
                    promises.push(traverseFileTree(entry, '', filesWithPaths));
                } else {
                    // webkitGetAsEntry가 지원되지 않는 경우 직접 파일 가져오기
                    const file = item.getAsFile();
                    if (file) {
                        filesWithPaths.push({ file, relativePath: file.name });
                    }
                }
            }
        }

        await Promise.all(promises);

        hideLoading();

        if (filesWithPaths.length === 0) {
            statusInfo.textContent = '업로드할 파일을 찾을 수 없습니다.';
            console.log('업로드할 파일이 없습니다.');
             return;
        }

        console.log(`총 ${filesWithPaths.length}개의 파일 수집 완료.`);
        // uploadFiles 함수 호출 시 targetPath 전달
        uploadFiles(filesWithPaths, targetPath); // 수정: targetPath 전달

    } catch (error) {
        hideLoading();
        statusInfo.textContent = '파일 목록 읽기 오류.';
        console.error('파일 트리 탐색 오류:', error);
        alert('파일 목록을 읽는 중 오류가 발생했습니다.');
    } finally {
        isHandlingDrop = false; // 처리 완료 또는 오류 발생 시 플래그 해제
    }
}

// 파일 트리 탐색 함수 (폴더 포함)


// 특정 폴더에 파일 업로드 (files 인자 변경: File[] -> { file: File, relativePath: string }[])
// targetUploadPath 인자 추가

// 파일/폴더 이동 함수

// 뷰 모드 전환

// 폴더 생성 기능 초기화

// 이름 변경 기능 초기화


// 파일 업로드 기능 초기화

// 잘라내기/붙여넣기 기능 초기화

// 삭제 기능 초기화

// 검색 기능 초기화

// 선택된 파일 다운로드

// 여러 파일/폴더를 압축하여 다운로드

// 항목 이동

// 상위 폴더로 이동

// 브라우저 히스토리 상태 업데이트

// 브라우저 뒤로가기/앞으로가기 이벤트 처리

// 파일 다운로드 및 실행 함수


// 페이지 로드 시 애플리케이션 초기화

// 선택한 파일 압축








// 정렬 아이콘 가져오기
function getSortIcon(field) {
    if (field !== sortField) return '';
    return sortDirection === 'asc' ? '<i class="fas fa-sort-up"></i>' : '<i class="fas fa-sort-down"></i>';
}

// 파일 아이콘 클래스 가져오기
function getFileIconClass(filename) {
    const ext = filename.split('.').pop().toLowerCase();
    
    // 파일 확장자별 아이콘 클래스
    const iconMap = {
        'pdf': 'far fa-file-pdf',
        'doc': 'far fa-file-word',
        'docx': 'far fa-file-word',
        'xls': 'far fa-file-excel',
        'xlsx': 'far fa-file-excel',
        'ppt': 'far fa-file-powerpoint',
        'pptx': 'far fa-file-powerpoint',
        'jpg': 'far fa-file-image',
        'jpeg': 'far fa-file-image',
        'png': 'far fa-file-image',
        'gif': 'far fa-file-image',
        'txt': 'far fa-file-alt',
        'zip': 'far fa-file-archive',
        'rar': 'far fa-file-archive',
        'mp3': 'far fa-file-audio',
        'wav': 'far fa-file-audio',
        'mp4': 'far fa-file-video',
        'mov': 'far fa-file-video',
        'js': 'far fa-file-code',
        'html': 'far fa-file-code',
        'css': 'far fa-file-code',
        'json': 'far fa-file-code',
    };
    
    return iconMap[ext] || 'far fa-file';
}

// 파일 크기 포맷
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    
    const units = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    
    return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + ' ' + units[i];
}

// 날짜 포맷
function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
}

// 경로 표시 업데이트
function updateBreadcrumb(path) {
    const parts = path.split('/').filter(part => part);
    let breadcrumbHTML = '<span data-path="">홈</span>';
    let currentPathBuilt = '';
    
    parts.forEach((part, index) => {
        currentPathBuilt += (index === 0) ? part : `/${part}`;
        breadcrumbHTML += ` / <span data-path="${currentPathBuilt}">${part}</span>`;
    });
    
    breadcrumb.innerHTML = breadcrumbHTML;
    
    // 경로 클릭 이벤트
    breadcrumb.querySelectorAll('span').forEach(span => {
        span.addEventListener('click', () => {
            currentPath = span.getAttribute('data-path');
            // 히스토리 상태 업데이트 추가
            updateHistoryState(currentPath);
    loadFiles(currentPath);
    
            // 선택 초기화
            clearSelection();
        });
    });
}

// 파일 클릭 처리
function handleFileClick(e, fileItem) {
    // 우클릭은 무시 (컨텍스트 메뉴용)
    if (e.button === 2) return;
    
    // 이름 변경 중이면 무시
    if (fileItem.classList.contains('renaming')) return;
    
    // 상위 폴더는 선택 처리하지 않음
    if (fileItem.getAttribute('data-parent-dir') === 'true') {
        return;
    }
    
    // Ctrl 또는 Shift 키로 다중 선택
    if (e.ctrlKey) {
        if (fileItem.classList.contains('selected')) {
            fileItem.classList.remove('selected');
            selectedItems.delete(fileItem.getAttribute('data-name'));
        } else {
            fileItem.classList.add('selected');
            selectedItems.add(fileItem.getAttribute('data-name'));
        }
    } else if (e.shiftKey && selectedItems.size > 0) {
        // Shift 키로 범위 선택
        const items = Array.from(document.querySelectorAll('.file-item:not([data-parent-dir="true"])'));
        const firstSelected = items.findIndex(item => item.classList.contains('selected'));
        const currentIndex = items.indexOf(fileItem);
        
        // 범위 설정
        const start = Math.min(firstSelected, currentIndex);
        const end = Math.max(firstSelected, currentIndex);
        
        clearSelection();
        
        for (let i = start; i <= end; i++) {
            items[i].classList.add('selected');
            selectedItems.add(items[i].getAttribute('data-name'));
        }
    } else {
        // 일반 클릭: 단일 선택
        const fileName = fileItem.getAttribute('data-name');
        
        // 모든 선택 해제 후 현재 항목 선택
        clearSelection();
        fileItem.classList.add('selected');
        selectedItems.add(fileName);
    }
    
    updateButtonStates();
}

// 파일 더블클릭 처리
function handleFileDblClick(e, fileItem) {
    // 이벤트 버블링 방지
    e.preventDefault();
    e.stopPropagation();
    
    // 더블클릭 이벤트가 비활성화된 상태이면 무시
    if (window.doubleClickEnabled === false) {
        console.log('더블클릭 이벤트가 비활성화 상태입니다.');
        return;
    }
    
    const isFolder = fileItem.getAttribute('data-is-folder') === 'true';
    const fileName = fileItem.getAttribute('data-name');
    const isParentDir = fileItem.getAttribute('data-parent-dir') === 'true';
    
    console.log(`더블클릭 이벤트 발생: ${fileName}, 폴더: ${isFolder}, 상위폴더: ${isParentDir}`);
    
    // 상위 폴더 처리
    if (isParentDir) {
        // 더블클릭 이벤트를 비활성화하고 탐색 진행
        window.doubleClickEnabled = false;
        navigateToParentFolder();
        return;
    }
    
    if (isFolder) {
        // 폴더로 이동 전에 더블클릭 비활성화
        window.doubleClickEnabled = false;
        // 폴더로 이동
        navigateToFolder(fileName);
    } else {
        // 파일 확장자에 따라 처리
        const fileExt = fileName.split('.').pop().toLowerCase();
        const filePath = currentPath ? `${currentPath}/${fileName}` : fileName;
        
        const encodedPath = encodeURIComponent(filePath);
        
        // 이미지, 비디오, PDF 등 브라우저에서 열 수 있는 파일 형식
        const viewableTypes = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 
                              'mp4', 'webm', 'ogg', 'mp3', 'wav', 
                              'pdf', 'txt', 'html', 'htm', 'css', 'js', 'json', 'xml'];
        
        if (viewableTypes.includes(fileExt)) {
            // 직접 보기 모드로 URL 생성 (view=true 쿼리 파라미터 추가)
            const fileUrl = `${API_BASE_URL}/api/files/${encodedPath}?view=true`;
            // 새 창에서 파일 열기
            window.open(fileUrl, '_blank');
        } else {
            // 다운로드
            downloadFile(fileName);
        }
    }
}

// 폴더 탐색
function navigateToFolder(folderName) {
    let newPath = currentPath ? `${currentPath}/${folderName}` : folderName;
    currentPath = newPath;
    
    // 폴더 이동 히스토리 상태 업데이트
    updateHistoryState(currentPath);
    
    // 이전 더블클릭 이벤트 리스너 제거를 위해 기존 파일 항목 캐시
    const oldFileItems = document.querySelectorAll('.file-item, .file-item-grid');
    oldFileItems.forEach(item => {
        const clonedItem = item.cloneNode(true);
        item.parentNode.replaceChild(clonedItem, item);
    });
    
    // 파일 목록 로드 전에 마우스 포인터 상태 리셋
    document.querySelectorAll('.file-item, .file-item-grid').forEach(item => {
        if (item.classList) {
            item.classList.remove('hover');
        }
    });
    
    // 마우스 포인터 위치 재설정을 위한 강제 mousemove 이벤트 등록
    // 파일 목록이 로드된 후 실행하기 위해 타이머 설정
    setTimeout(() => {
        try {
            // 마우스 위치가 있을 경우에만 이벤트 발생
            if (typeof window.mouseX === 'number' && typeof window.mouseY === 'number') {
                // 마우스 이벤트 강제 발생 
                const mouseEvent = new MouseEvent('mousemove', {
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    clientX: window.mouseX,
                    clientY: window.mouseY
                });
                document.dispatchEvent(mouseEvent);
            }
        } catch (error) {
            console.error('마우스 이벤트 강제 발생 중 오류:', error);
        }
    }, 350);
    
    // 파일 목록 로드
    loadFiles(newPath);
    
    // 선택 초기화
        clearSelection();
}

// 이름 변경 다이얼로그 표시
function showRenameDialog() {
    if (selectedItems.size !== 1) return;
    
    const selectedItem = document.querySelector('.file-item.selected');
    const currentName = selectedItem.getAttribute('data-name');
}
// 선택 항목 삭제 (백그라운드 처리 UX 개선)
async function deleteSelectedItems() { // async 키워드 추가
    if (selectedItems.size === 0) return;
    
    const itemList = Array.from(selectedItems);
    const itemCount = itemList.length;

    // 잠긴 폴더 확인 (기존 로직 유지)
    const hasRestrictedItems = itemList.some(itemName => {
        const itemPath = currentPath ? `${currentPath}/${itemName}` : itemName;
        return isPathAccessRestricted(itemPath);
    });
    if (hasRestrictedItems) {
        alert('잠긴 폴더 또는 파일은 삭제할 수 없습니다.');
            return;
        }

    if (!confirm(`선택한 ${itemCount}개 항목을 삭제하시겠습니까?\n(대용량 폴더는 백그라운드에서 처리됩니다.)`)) {
            return;
        }

    showLoading();
    statusInfo.textContent = `삭제 요청 중... (0/${itemCount})`;

    let successCount = 0;
    let failureCount = 0;
    const itemsToDeleteUI = []; // UI에서 숨길 항목들

    // 모든 삭제 요청을 병렬로 보냄
    const deletePromises = itemList.map(async (itemName, index) => {
        const itemPath = currentPath ? `${currentPath}/${itemName}` : itemName;
        const encodedPath = encodeURIComponent(itemPath);

        try {
            const response = await fetch(`${API_BASE_URL}/api/files/${encodedPath}`, {
                method: 'DELETE'
            });

            statusInfo.textContent = `삭제 요청 중... (${index + 1}/${itemCount})`;

            // 202 (Accepted) 또는 200/204 (OK/No Content)면 성공으로 간주하고 UI에서 숨김
            if (response.status === 202 || response.status === 200 || response.status === 204) {
                console.log(`'${itemName}' 삭제 요청 성공 (상태: ${response.status})`);
                successCount++;
                // UI에서 숨길 항목 추가
                const element = document.querySelector(`.file-item[data-name=\"${CSS.escape(itemName)}\"]`);
                if (element) itemsToDeleteUI.push(element);
                } else {
                // 기타 응답은 실패로 간주
                failureCount++;
                const errorText = await response.text();
                console.error(`'${itemName}' 삭제 요청 실패: ${response.status} ${errorText}`);
                // 실패한 항목은 UI에 그대로 둠 (오류 메시지는 아래에서 한번에)
            }
        } catch (error) {
            failureCount++;
            console.error(`'${itemName}' 삭제 요청 오류:`, error);
        }
    });

    // 모든 요청이 완료될 때까지 기다림
    await Promise.all(deletePromises);

        hideLoading();

    // 성공한 항목들 UI에서 숨기기
    itemsToDeleteUI.forEach(element => {
        element.remove(); // 또는 element.style.display = 'none';
    });
  
      // *** 삭제 후 파일 목록 확인 및 빈 메시지 표시 로직 수정 (메시지 상단 표시) ***
      const remainingItems = fileList.querySelectorAll('.file-item, .file-item-grid');
      if (remainingItems.length === 0) {
          const header = fileList.querySelector('.file-list-header');
          const emptyMessageElement = document.createElement('p');
          emptyMessageElement.className = 'empty-message';
          emptyMessageElement.textContent = '파일이 없습니다';

          // 기존 파일 아이템과 메시지 모두 제거 (중복 방지)
          fileList.querySelectorAll('.file-item, .empty-message').forEach(el => el.remove());

          if (listView && header) { // 목록 보기 상태이고 헤더가 있으면
              // 헤더 바로 다음에 메시지 삽입
              header.insertAdjacentElement('afterend', emptyMessageElement);
          } else { // 격자 보기 또는 헤더 없는 경우
               // fileList의 가장 처음에 메시지 삽입
              fileList.innerHTML = ''; // 일단 비우고
              fileList.appendChild(emptyMessageElement); // 맨 위에 추가
              if(header) fileList.insertBefore(header, emptyMessageElement); // 격자보기였다면 헤더가 없을수 있으므로 확인 후 헤더 복구(필요시) - 격자보기에선 헤더 필요없을듯
          }
          // 상태바 정보 업데이트
          statusInfo.textContent = '0개 항목';
      } else {
          // 남은 항목 수 업데이트
          statusInfo.textContent = `${remainingItems.length}개 항목`;
          // 혹시 이전에 표시된 빈 메시지가 있다면 제거
          const emptyMessageElement = fileList.querySelector('.empty-message');
          if (emptyMessageElement) {
              emptyMessageElement.remove();
          }
      }
      // *** 로직 수정 끝 ***


    // 선택 해제
    clearSelection();
    selectedItems.clear(); // Set 비우기
    updateButtonStates();

    // 최종 상태 메시지 표시
    let finalMessage = '';
    if (failureCount > 0) {
        finalMessage = `${successCount}개 항목 삭제 요청 성공, ${failureCount}개 실패.`;
        alert(`일부 항목 삭제 요청에 실패했습니다. 로그를 확인하세요.`); // 간단한 알림
    } else {
        finalMessage = `${successCount}개 항목 삭제 작업이 백그라운드에서 시작되었습니다.`;
    }
    statusInfo.textContent = finalMessage;
// 중요: 여기서 loadFiles()를 호출하지 않음!
// 필요하다면 몇 초 후 새로고침하는 타이머 추가 가능
// setTimeout(() => loadFiles(currentPath), 15000); // 예: 15초 후 새로고침

// 항목 붙여넣기
function pasteItems() {
    if (clipboardItems.length === 0) return;
    
    const promises = [];
    showLoading();
    statusInfo.textContent = '붙여넣기 중...';
    
    clipboardItems.forEach(item => {
        // 소스 경로 (원본 파일 경로)
        const sourcePath = item.originalPath ? `${item.originalPath}/${item.name}` : item.name;
        // 대상 경로 (현재 경로)
        // 현재 경로가 비어있으면 루트('/') 경로로 처리
        const targetPathBase = (currentPath === '') ? '' : currentPath;
        
        // 경로에 한글이 포함된 경우를 위해 인코딩 처리
        const encodedSourcePath = encodeURIComponent(sourcePath);
        
        if (clipboardOperation === 'cut') {
            console.log(`이동 요청: 소스=${sourcePath}, 대상 경로=${targetPathBase}, 파일명=${item.name}, 현재경로=${currentPath}`);
            
            // 잘라내기는 이름 변경(이동)으로 처리
            promises.push(
                fetch(`${API_BASE_URL}/api/files/${encodedSourcePath}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        newName: item.name,
                        targetPath: targetPathBase
                    })
                })
                .then(response => {
                    // 응답이 정상적이지 않으면 에러 텍스트 추출
                    if (!response.ok) {
                        return response.text().then(text => {
                            throw new Error(text || `${item.name} 이동 실패 (${response.status})`);
                        });
                    }
                    
                    // 이동된 항목 표시에서 'cut' 클래스 제거
                    document.querySelectorAll('.file-item.cut').forEach(el => {
                        el.classList.remove('cut');
                    });
                    
                    return item.name;
                })
            );
        }
    });
    
    Promise.all(promises)
        .then(() => {
            // 클립보드 초기화
            clipboardItems = [];
            clipboardOperation = '';
            pasteBtn.disabled = true;
            document.getElementById('ctxPaste').style.display = 'none';
            
            // 파일 목록 새로고침
            loadFiles(currentPath);
            statusInfo.textContent = `${promises.length}개 항목 붙여넣기 완료`;
            hideLoading();
        })

        .catch(error => {
            alert(`오류 발생: ${error.message}`);
            hideLoading();
        });
}

// 외부 파일 드롭 처리 함수 -> upload.js 로 이동됨
/*
async function handleExternalFileDrop(e, targetFolderItem = null) { // async 키워드 추가
    if (isHandlingDrop) {
        console.log('이미 드롭 처리 중입니다. 중복 호출 방지.');
        return; // 중복 실행 방지
    }
    isHandlingDrop = true; // 처리 시작 플래그 설정

    try {
        // 진행 중인 업로드가 있는지 확인
        if (progressContainer.style.display === 'block') {
            statusInfo.textContent = '이미 업로드가 진행 중입니다. 완료 후 다시 시도하세요.';
            console.log('이미 진행 중인 업로드가 있어 새 업로드를 취소합니다.');
            return;
        }

        // DataTransferItemList 사용
        const items = e.dataTransfer.items;
        if (!items || items.length === 0) {
            console.log('드롭된 항목이 없습니다.');
            return;
        }

        // 업로드 소스 설정 및 카운터 초기화
        uploadSource = 'dragdrop';
        dragDropCounter = 0;

        let targetPath = currentPath; // 기본 업로드 경로는 현재 경로

        // 타겟 폴더가 지정된 경우 경로 업데이트
        if (targetFolderItem) {
            const targetFolder = targetFolderItem.getAttribute('data-name');
            targetPath = currentPath ? `${currentPath}/${targetFolder}` : targetFolder;
            console.log('외부 파일 드래그 감지: 대상 폴더:', targetFolder);
        } else {
            console.log('외부 파일 드래그 감지: 현재 경로에 업로드');
        }

        showLoading();
        statusInfo.textContent = '파일 목록을 읽는 중...';

        const filesWithPaths = [];
        const promises = [];

        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item.kind === 'file') {
                const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : null;
                if (entry) {
                    promises.push(traverseFileTree(entry, '', filesWithPaths));
                } else {
                    // webkitGetAsEntry가 지원되지 않는 경우 직접 파일 가져오기
                    const file = item.getAsFile();
                    if (file) {
                        filesWithPaths.push({ file, relativePath: file.name });
                    }
                }
            }
        }

        await Promise.all(promises);

        hideLoading();

        if (filesWithPaths.length === 0) {
            statusInfo.textContent = '업로드할 파일을 찾을 수 없습니다.';
            console.log('업로드할 파일이 없습니다.');
             return;
        }

        console.log(`총 ${filesWithPaths.length}개의 파일 수집 완료.`);
        // uploadFiles 함수 호출 시 targetPath 전달
        uploadFiles(filesWithPaths, targetPath); // 수정: targetPath 전달

    } catch (error) {
        hideLoading();
        statusInfo.textContent = '파일 목록 읽기 오류.';
        console.error('파일 트리 탐색 오류:', error);
        alert('파일 목록을 읽는 중 오류가 발생했습니다.');
    } finally {
        isHandlingDrop = false; // 처리 완료 또는 오류 발생 시 플래그 해제
    }
}
*/
            loadFiles(currentPath);
                // 내부 경로로 판단되고 경로가 채워짐
                result.reason = `내부 경로 패턴 확인됨: ${paths.join(', ')}`;
                console.log(`[내외부 판단] 결과: 내부, 이유: ${result.reason}`);
            }
        }
    }
    
    // JSON 데이터 확인
    if (dataTypes.includes('application/json')) {
        try {
            const jsonData = JSON.parse(e.dataTransfer.getData('application/json'));
            if (jsonData.source === 'internal' && Array.isArray(jsonData.items) && jsonData.items.length > 0) {
                // JSON에 내부 파일 정보가 있고 draggedPaths가 아직 채워지지 않았으면 채움
                if (result.draggedPaths.length === 0) {
                    result.draggedPaths = jsonData.items;
                }
                result.isInternalDrop = true;
                result.isExternalDrop = false;
                result.reason = `JSON 메타데이터에서 내부 소스 확인: ${jsonData.source}`;
                console.log(`[내외부 판단] 결과: 내부, 이유: ${result.reason}`);
            }
        } catch (error) {
            console.error('JSON 데이터 파싱 오류:', error);
        }
    }
    
    // 경로가 비어있고 내부 드롭인 경우, 선택된 항목 사용
    if (result.isInternalDrop && result.draggedPaths.length === 0) {
        result.draggedPaths = Array.from(selectedItems).map(name => 
            currentPath ? `${currentPath}/${name}` : name);
        result.reason = `선택된 항목에서 경로 추출: ${result.draggedPaths.join(', ')}`;
        console.log(`[내외부 판단] 결과: 내부, 이유: ${result.reason}`);
    }
    
    // 외부 파일이 있으면 내부 드롭을 덮어씀 (외부가 우선)
    if (result.isExternalDrop) {
        result.isInternalDrop = false;
    }
    
    // 최종 판단 로그
    console.log(`[내외부 판단] 최종 결과: ${result.isInternalDrop ? '내부' : '외부'}, 이유: ${result.reason}`);
    
    return result;
}

// 파일/폴더가 드롭되었을 때 호출되는 통합 함수
function handleFileDrop(e, targetFolderItem = null) {
    preventDefaults(e);
    
    // 드래그 상태 초기화
    window.draggingInProgress = false;
    
    // 드롭존 비활성화
    dropZone.classList.remove('active');

    // targetFolderItem이 없으면 드롭된 위치에서 찾음
    if (!targetFolderItem) {
        targetFolderItem = e.target.closest('.file-item');
    }
    
    // 타겟 폴더 정보 로깅
    if (targetFolderItem) {
        const targetName = targetFolderItem.getAttribute('data-name');
        const targetPath = targetFolderItem.getAttribute('data-path') || currentPath;
        console.log(`폴더에 파일 드롭됨 - 대상: ${targetName}, 경로: ${targetPath}`);
        
        // 상위 디렉토리로 이동 처리는 무시
        if (targetName === '..' || targetFolderItem.hasAttribute('data-parent-dir')) {
            console.log('상위 디렉토리로의 이동은 처리하지 않음');
            return;
        }
        
        // 드래그 오버 스타일 제거
        targetFolderItem.classList.remove('drag-over');
    } else {
        console.log('빈 영역에 파일 드롭됨 - 현재 경로에 처리');
    }

    // 내부/외부 파일 판단
    const { isExternalDrop, isInternalDrop, draggedPaths, reason } = determineDropType(e);
    
    // 최종 판단 로그 출력
    console.log(`파일 드롭 처리: ${isInternalDrop ? '내부' : '외부'} 파일, 이유: ${reason}`);
    
    // 최종 판단: 외부 파일이 있으면 외부 드롭으로 처리 (우선순위)
    if (isExternalDrop) {
        console.log('외부 파일 드롭으로 최종 판단');
        
        // 폴더가 아닌 항목 또는 빈 공간에 드롭된 경우 현재 경로에 업로드
        if (!targetFolderItem || targetFolderItem.getAttribute('data-is-folder') !== 'true') {
            console.log('현재 디렉토리에 외부 파일 업로드');
            handleExternalFileDrop(e); // 현재 경로에 업로드
        } else {
            // 폴더 항목에 드롭된 경우 해당 폴더를 타겟으로 지정
            console.log(`'${targetFolderItem.getAttribute('data-name')}' 폴더에 외부 파일 업로드`);
            handleExternalFileDrop(e, targetFolderItem);
        }
    } 
    // 내부 파일 이동 처리
    else if (isInternalDrop && draggedPaths.length > 0) {
        console.log('내부 파일 이동으로 최종 판단');
        
        // 자기 자신에게 드롭하거나 선택된 항목에 드롭하는 경우 방지
        if (targetFolderItem && targetFolderItem.classList.contains('selected')) {
            console.log('선택된 항목에는 드롭할 수 없음');
            return;
        }
        
        // 타겟이 폴더인 경우에만 이동 처리
        if (!targetFolderItem || targetFolderItem.getAttribute('data-is-folder') === 'true') {
            // 내부 파일 이동 처리 (경로 배열과 타겟 폴더 정보 전달)
            handleInternalFileDrop(draggedPaths, targetFolderItem);
        } else {
            console.log('파일에 드롭됨: 폴더가 아니므로 이동할 수 없습니다.');
        }
    } 
    // 처리할 수 없는 드롭
    else {
        console.log('처리할 수 없는 드롭 형식 또는 데이터 없음');
        showToast('처리할 수 없는 드롭 데이터입니다.', 'error');
        
    }
    
    // 전체 영역 드롭존 이벤트 리스너 등록
    window.removeEventListener('dragenter', handleDropZoneDragEnter);
    window.removeEventListener('dragover', handleDropZoneDragOver);
    window.removeEventListener('dragleave', handleDropZoneDragLeave);
    dropZone.removeEventListener('drop', handleDropZoneDrop);
    
    console.log('드롭존 이벤트 리스너 등록 완료 (handleDrop 이벤트는 initDropZone에서 등록)');
    
    // 개발 모드에서 폴더 항목 CSS 선택자 유효성 확인
    console.log('폴더 항목 개수:', document.querySelectorAll('.file-item[data-is-folder="true"]').length);
}